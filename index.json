[
{
	"uri": "https://iuyte.github.io/about/mentors/",
	"title": "Our Mentors",
	"tags": [],
	"description": "",
	"content": "Our mentors are the most amazing mentors EVER!!!\nThey exemplify kindness, leadership, and encourage us to approach problems in new, creative ways. Without them, we simply would not have a team. So, a big shoutout to our Mother and Father, Rick and Lisa, as well as our brother Parker, for their unending support and tolerance of our travels with robotics.\nNOTE: Rick and Lisa did in fact earn the Mentor of the Year Award at the Northern New York State Championship! Spencer and I are firmly of the belief that they truly deserve it, for all that they do.\n"
},
{
	"uri": "https://iuyte.github.io/about/spencer/",
	"title": "Spencer",
	"tags": [],
	"description": "Spencer&#39;s Mini Autobiography",
	"content": "Contact: beanwells@icloud.com\nRoles: Lead Builder, Lead Designer\nClass: 2019\nGrades: Not good enough\nOccupations: Pretending to study while actually on youtube\n"
},
{
	"uri": "https://iuyte.github.io/about/",
	"title": "About Our Team Members",
	"tags": [],
	"description": "Mini Autobiographies",
	"content": ""
},
{
	"uri": "https://iuyte.github.io/about/ethan/",
	"title": "Ethan",
	"tags": [],
	"description": "Ethan&#39;s Mini Autobiography",
	"content": "Contact: ethanialw@gmail.com\nRoles: Lead Programmer, Website Creator / Maintainer, Apprentice Builder / Designer\nClass: 2021\nLikes:  Programming Languages:  Python HTML CSS Javascript C C++   Linux (currently running Linux Mint, possibly switching to Arch in the future) Learning, especially STEAM things Space, specifically astrophysics and rocket science \nDislikes:  Java (it\u0026rsquo;s overused and unproductive) Canned Corn \n"
},
{
	"uri": "https://iuyte.github.io/notebook/programming/",
	"title": "Programming Engineering Notebook",
	"tags": [],
	"description": "A log off all that was programmed",
	"content": "  body { align: center; background-color: white; //#bfbfdf; width: 100%; margin: 0px; font-family: 'Open Sans', sans-serif; } .link { color: #323232; text-decoration: none; word-wrap: break-word; } .link:visited { color: #323232; text-decoration: none; cursor: auto; } .link:hover { color: #0000EE; text-decoration: underline; cursor: pointer; } .commit { background-color: #efefef; width: 90%; align: center; align-self: center; align-content: center; align-items: center; border-color: #454585; border-style: groove inset; border-radius: 25px; padding: 20px; margin: 5%; box-shadow: 10px 10px 5px #777777; } .em { cursor: pointer; } .spacer { height: 5%; } .bcon { width: 8%; } .browse { background-color: #454585; color: white; border: 2px solid #454585; border-radius: 4px; position: absolute; right: 25%; display: none; } .browse:hover { background-color: #bfbfdf; border-color: #9d9dbf; color: #323232; } h1 { font-size: 275%; } h2 { font-size: 170%; } .centered { text-align: center; } #body-inner h1 { background-color: #efefef; width: 90%; color: #333333; font-weight: lighter; font-family: 'Open Sans', sans-serif; align: center; align-self: center; align-content: center; align-items: center; border-color: #454585; border-style: groove inset; border-radius: 25px; padding: 20px; margin: 5%; box-shadow: 10px 10px 5px #777777; }   Commit: 90ef0c60cfa17383c5e897b46affcbc88c468565\nDate: Thu Jun 22 15:38:18 2017 -0400\nAuthor: iuyte \nDescription:\npid now takes battery i=voltage into account\nFiles modified:  src/pid.cpp \n Commit: cc8ca4688dd225876ca3c02d44e434e433900d56\nDate: Wed Jun 21 20:30:58 2017 -0400\nAuthor: iuyte \nDescription:\nRemoved Doxygen, because it is of no use as of yet\nFiles added:  resources/AppendixB.pdf resources/AppendixE.pdf resources/Manual.pdf resources/appendix_a.zip resources/appendix_a/FieldSpecs.pdf resources/appendix_a/LowCostFieldOptions-042217.pdf Files deleted:  resources/VRC-InTheZone-AppendixA-042217.zip resources/VRC-InTheZone-AppendixA-FieldSpecs-042217.pdf resources/VRC-InTheZone-AppendixB-RobotSkills-042217.pdf resources/VRC-InTheZone-AppendixE-VEXU-042217.pdf resources/VRC-InTheZone-GameManual-042217.pdf resources/VRC-InTheZone-LowCostFieldOptions-042217.pdf tools/Doxyfile \n Commit: c37dcc0fb5165d4a70b7ea6abf4d5aa68ffd1cdf\nDate: Sun Jun 18 02:09:33 2017 -0400\nAuthor: iuyte \nDescription:\nFixed pdfs ending up in project root, changed git add * to -u, and\nFiles modified:  docs/cleanuphelp.py tools/commit.sh tools/pdfMaker.sh Files deleted:  auto.pdf debug.pdf drive.pdf gyro.pdf init.pdf lift.pdf motors.pdf opcontrol.pdf pid.pdf sensors.pdf \n Commit: 4d118b82180aecdb22632738e895caf010dd8187\nDate: Sun Jun 18 01:56:57 2017 -0400\nAuthor: iuyte \nDescription:\nMoved pdf stuff, doxygen, etc into tools, other work with them as well\nFiles added:  auto.pdf debug.pdf drive.pdf gyro.pdf init.pdf lift.pdf motors.pdf opcontrol.pdf pid.pdf sensors.pdf tools/Doxyfile tools/pdfMaker.sh Files modified:  tools/commit.sh Files deleted:  Doxyfile LATEX/include/API.tex LATEX/include/debug.tex LATEX/include/drive.tex LATEX/include/gyro.tex LATEX/include/lift.tex LATEX/include/main.tex LATEX/include/motors.tex LATEX/include/pid.tex LATEX/include/sensors.tex LATEX/src/auto.tex LATEX/src/debug.tex LATEX/src/drive.tex LATEX/src/gyro.tex LATEX/src/init.tex LATEX/src/lift.tex LATEX/src/motors.tex LATEX/src/opcontrol.tex LATEX/src/pid.tex LATEX/src/sensors.tex PDFs/include/debug.pdf PDFs/include/drive.pdf PDFs/include/gyro.pdf PDFs/include/lift.pdf PDFs/include/motors.pdf PDFs/include/pid.pdf PDFs/include/sensors.pdf PDFs/src/auto.pdf PDFs/src/debug.pdf PDFs/src/drive.pdf PDFs/src/gyro.pdf PDFs/src/init.pdf PDFs/src/lift.pdf PDFs/src/motors.pdf PDFs/src/opcontrol.pdf PDFs/src/pid.pdf PDFs/src/sensors.pdf doxygen/html/API_8h.html doxygen/html/API_8h_source.html doxygen/html/annotated.html doxygen/html/bc_s.png doxygen/html/bdwn.png doxygen/html/classcommit_1_1Commit-members.html doxygen/html/classcommit_1_1Commit.html doxygen/html/classcommit_1_1Commit.png doxygen/html/classes.html doxygen/html/classgyro_1_1drive-members.html doxygen/html/classgyro_1_1drive.html doxygen/html/classsensors_1_1gyro__t-members.html doxygen/html/classsensors_1_1gyro__t.html doxygen/html/closed.png doxygen/html/debug_8hpp_source.html doxygen/html/dir_49e56c817e5e54854c35e136979f97ca.html doxygen/html/dir_68267d1309a1af8e8297ef4c3efbcdba.html doxygen/html/dir_d44c64559bbebec7f509842c48db8b23.html doxygen/html/doc.png doxygen/html/doxygen.css doxygen/html/doxygen.png doxygen/html/drive_8hpp_source.html doxygen/html/dynsections.js doxygen/html/files.html doxygen/html/folderclosed.png doxygen/html/folderopen.png doxygen/html/functions.html doxygen/html/functions_func.html doxygen/html/functions_vars.html doxygen/html/globals.html doxygen/html/globals_defs.html doxygen/html/globals_func.html doxygen/html/globals_type.html doxygen/html/gyro_8hpp_source.html doxygen/html/hierarchy.html doxygen/html/index.html doxygen/html/jquery.js doxygen/html/lift_8hpp_source.html doxygen/html/main_8h.html doxygen/html/main_8h_source.html doxygen/html/md_README.html doxygen/html/menu.js doxygen/html/menudata.js doxygen/html/motors_8hpp_source.html doxygen/html/namespacedebug.html doxygen/html/namespacedrive.html doxygen/html/namespacedrive_1_1accel.html doxygen/html/namespacelift.html doxygen/html/namespacemembers.html doxygen/html/namespacemembers_enum.html doxygen/html/namespacemembers_func.html doxygen/html/namespacemembers_vars.html doxygen/html/namespacemotors.html doxygen/html/namespacemotors_1_1slew.html doxygen/html/namespacepid.html doxygen/html/namespaces.html doxygen/html/namespacesensors.html doxygen/html/nav_f.png doxygen/html/nav_g.png doxygen/html/nav_h.png doxygen/html/open.png doxygen/html/pages.html doxygen/html/pid_8hpp_source.html doxygen/html/search/all_0.html doxygen/html/search/all_0.js doxygen/html/search/all_1.html doxygen/html/search/all_1.js doxygen/html/search/all_10.html doxygen/html/search/all_10.js doxygen/html/search/all_11.html doxygen/html/search/all_11.js doxygen/html/search/all_12.html doxygen/html/search/all_12.js doxygen/html/search/all_13.html doxygen/html/search/all_13.js doxygen/html/search/all_14.html doxygen/html/search/all_14.js doxygen/html/search/all_15.html doxygen/html/search/all_15.js doxygen/html/search/all_16.html doxygen/html/search/all_16.js doxygen/html/search/all_17.html doxygen/html/search/all_17.js doxygen/html/search/all_18.html doxygen/html/search/all_18.js doxygen/html/search/all_19.html doxygen/html/search/all_19.js doxygen/html/search/all_2.html doxygen/html/search/all_2.js doxygen/html/search/all_3.html doxygen/html/search/all_3.js doxygen/html/search/all_4.html doxygen/html/search/all_4.js doxygen/html/search/all_5.html doxygen/html/search/all_5.js doxygen/html/search/all_6.html doxygen/html/search/all_6.js doxygen/html/search/all_7.html doxygen/html/search/all_7.js doxygen/html/search/all_8.html doxygen/html/search/all_8.js doxygen/html/search/all_9.html doxygen/html/search/all_9.js doxygen/html/search/all_a.html doxygen/html/search/all_a.js doxygen/html/search/all_b.html doxygen/html/search/all_b.js doxygen/html/search/all_c.html doxygen/html/search/all_c.js doxygen/html/search/all_d.html doxygen/html/search/all_d.js doxygen/html/search/all_e.html doxygen/html/search/all_e.js doxygen/html/search/all_f.html doxygen/html/search/all_f.js doxygen/html/search/classes_0.html doxygen/html/search/classes_0.js doxygen/html/search/classes_1.html doxygen/html/search/classes_1.js doxygen/html/search/classes_2.html doxygen/html/search/classes_2.js doxygen/html/search/classes_3.html doxygen/html/search/classes_3.js doxygen/html/search/classes_4.html doxygen/html/search/classes_4.js doxygen/html/search/classes_5.html doxygen/html/search/classes_5.js doxygen/html/search/classes_6.html doxygen/html/search/classes_6.js doxygen/html/search/classes_7.html doxygen/html/search/classes_7.js doxygen/html/search/close.png doxygen/html/search/defines_0.html doxygen/html/search/defines_0.js doxygen/html/search/defines_1.html doxygen/html/search/defines_1.js doxygen/html/search/defines_2.html doxygen/html/search/defines_2.js doxygen/html/search/defines_3.html doxygen/html/search/defines_3.js doxygen/html/search/defines_4.html doxygen/html/search/defines_4.js doxygen/html/search/defines_5.html doxygen/html/search/defines_5.js doxygen/html/search/defines_6.html doxygen/html/search/defines_6.js doxygen/html/search/defines_7.html doxygen/html/search/defines_7.js doxygen/html/search/defines_8.html doxygen/html/search/defines_8.js doxygen/html/search/defines_9.html doxygen/html/search/defines_9.js doxygen/html/search/defines_a.html doxygen/html/search/defines_a.js doxygen/html/search/enums_0.html doxygen/html/search/enums_0.js doxygen/html/search/files_0.html doxygen/html/search/files_0.js doxygen/html/search/files_1.html doxygen/html/search/files_1.js doxygen/html/search/functions_0.html doxygen/html/search/functions_0.js doxygen/html/search/functions_1.html doxygen/html/search/functions_1.js doxygen/html/search/functions_10.html doxygen/html/search/functions_10.js doxygen/html/search/functions_11.html doxygen/html/search/functions_11.js doxygen/html/search/functions_12.html doxygen/html/search/functions_12.js doxygen/html/search/functions_13.html doxygen/html/search/functions_13.js doxygen/html/search/functions_14.html doxygen/html/search/functions_14.js doxygen/html/search/functions_2.html doxygen/html/search/functions_2.js doxygen/html/search/functions_3.html doxygen/html/search/functions_3.js doxygen/html/search/functions_4.html doxygen/html/search/functions_4.js doxygen/html/search/functions_5.html doxygen/html/search/functions_5.js doxygen/html/search/functions_6.html doxygen/html/search/functions_6.js doxygen/html/search/functions_7.html doxygen/html/search/functions_7.js doxygen/html/search/functions_8.html doxygen/html/search/functions_8.js doxygen/html/search/functions_9.html doxygen/html/search/functions_9.js doxygen/html/search/functions_a.html doxygen/html/search/functions_a.js doxygen/html/search/functions_b.html doxygen/html/search/functions_b.js doxygen/html/search/functions_c.html doxygen/html/search/functions_c.js doxygen/html/search/functions_d.html doxygen/html/search/functions_d.js doxygen/html/search/functions_e.html doxygen/html/search/functions_e.js doxygen/html/search/functions_f.html doxygen/html/search/functions_f.js doxygen/html/search/mag_sel.png doxygen/html/search/namespaces_0.html doxygen/html/search/namespaces_0.js doxygen/html/search/namespaces_1.html doxygen/html/search/namespaces_1.js doxygen/html/search/namespaces_2.html doxygen/html/search/namespaces_2.js doxygen/html/search/namespaces_3.html doxygen/html/search/namespaces_3.js doxygen/html/search/namespaces_4.html doxygen/html/search/namespaces_4.js doxygen/html/search/nomatches.html doxygen/html/search/pages_0.html doxygen/html/search/pages_0.js doxygen/html/search/search.css doxygen/html/search/search.js doxygen/html/search/search_l.png doxygen/html/search/search_m.png doxygen/html/search/search_r.png doxygen/html/search/searchdata.js doxygen/html/search/typedefs_0.html doxygen/html/search/typedefs_0.js doxygen/html/search/typedefs_1.html doxygen/html/search/typedefs_1.js doxygen/html/search/typedefs_2.html doxygen/html/search/typedefs_2.js doxygen/html/search/typedefs_3.html doxygen/html/search/typedefs_3.js doxygen/html/search/typedefs_4.html doxygen/html/search/typedefs_4.js doxygen/html/search/typedefs_5.html doxygen/html/search/typedefs_5.js doxygen/html/search/typedefs_6.html doxygen/html/search/typedefs_6.js doxygen/html/search/typedefs_7.html doxygen/html/search/typedefs_7.js doxygen/html/search/variables_0.html doxygen/html/search/variables_0.js doxygen/html/search/variables_1.html doxygen/html/search/variables_1.js doxygen/html/search/variables_2.html doxygen/html/search/variables_2.js doxygen/html/search/variables_3.html doxygen/html/search/variables_3.js doxygen/html/search/variables_4.html doxygen/html/search/variables_4.js doxygen/html/search/variables_5.html doxygen/html/search/variables_5.js doxygen/html/search/variables_6.html doxygen/html/search/variables_6.js doxygen/html/search/variables_7.html doxygen/html/search/variables_7.js doxygen/html/search/variables_8.html doxygen/html/search/variables_8.js doxygen/html/search/variables_9.html doxygen/html/search/variables_9.js doxygen/html/search/variables_a.html doxygen/html/search/variables_a.js doxygen/html/search/variables_b.html doxygen/html/search/variables_b.js doxygen/html/search/variables_c.html doxygen/html/search/variables_c.js doxygen/html/search/variables_d.html doxygen/html/search/variables_d.js doxygen/html/search/variables_e.html doxygen/html/search/variables_e.js doxygen/html/sensors_8hpp_source.html doxygen/html/splitbar.png doxygen/html/structdrive_1_1side__t-members.html doxygen/html/structdrive_1_1side__t.html doxygen/html/structlift_1_1side__t-members.html doxygen/html/structlift_1_1side__t.html doxygen/html/structmotor__t-members.html doxygen/html/structmotor__t.html doxygen/html/structsensors_1_1button__t-members.html doxygen/html/structsensors_1_1button__t.html doxygen/html/structsensors_1_1pot__t-members.html doxygen/html/structsensors_1_1pot__t.html doxygen/html/structsensors_1_1quad__t-members.html doxygen/html/structsensors_1_1quad__t.html doxygen/html/structsensors_1_1sonic__t-members.html doxygen/html/structsensors_1_1sonic__t.html doxygen/html/sync_off.png doxygen/html/sync_on.png doxygen/html/tab_a.png doxygen/html/tab_b.png doxygen/html/tab_h.png doxygen/html/tab_s.png doxygen/html/tabs.css doxygen/latex/API_8h.tex doxygen/latex/Makefile doxygen/latex/annotated.tex doxygen/latex/classcommit_1_1Commit.eps doxygen/latex/classcommit_1_1Commit.tex doxygen/latex/classgyro_1_1drive.tex doxygen/latex/classsensors_1_1gyro__t.tex doxygen/latex/doxygen.sty doxygen/latex/files.tex doxygen/latex/hierarchy.tex doxygen/latex/main_8h.tex doxygen/latex/md_README.tex doxygen/latex/namespacedebug.tex doxygen/latex/namespacedrive.tex doxygen/latex/namespacedrive_1_1accel.tex doxygen/latex/namespacelift.tex doxygen/latex/namespacemotors.tex doxygen/latex/namespacemotors_1_1slew.tex doxygen/latex/namespacepid.tex doxygen/latex/namespaces.tex doxygen/latex/namespacesensors.tex doxygen/latex/refman.aux doxygen/latex/refman.idx doxygen/latex/refman.pdf doxygen/latex/refman.tex doxygen/latex/refman.toc doxygen/latex/structdrive_1_1side__t.tex doxygen/latex/structlift_1_1side__t.tex doxygen/latex/structmotor__t.tex doxygen/latex/structsensors_1_1button__t.tex doxygen/latex/structsensors_1_1pot__t.tex doxygen/latex/structsensors_1_1quad__t.tex doxygen/latex/structsensors_1_1sonic__t.tex pdfMaker.sh \n Commit: 00173cea18b7bd0dc231a5693c1cb7b73ca73e0f\nDate: Sat Jun 17 22:05:37 2017 -0400\nAuthor: iuyte \nDescription:\nDid doxygen more, and code PDFs\nFiles added:  LATEX/include/API.tex LATEX/include/debug.tex LATEX/include/drive.tex LATEX/include/gyro.tex LATEX/include/lift.tex LATEX/include/main.tex LATEX/include/motors.tex LATEX/include/pid.tex LATEX/include/sensors.tex LATEX/src/auto.tex LATEX/src/debug.tex LATEX/src/drive.tex LATEX/src/gyro.tex LATEX/src/init.tex LATEX/src/lift.tex LATEX/src/motors.tex LATEX/src/opcontrol.tex LATEX/src/pid.tex LATEX/src/sensors.tex PDFs/include/debug.pdf PDFs/include/drive.pdf PDFs/include/gyro.pdf PDFs/include/lift.pdf PDFs/include/motors.pdf PDFs/include/pid.pdf PDFs/include/sensors.pdf PDFs/src/auto.pdf PDFs/src/debug.pdf PDFs/src/drive.pdf PDFs/src/gyro.pdf PDFs/src/init.pdf PDFs/src/lift.pdf PDFs/src/motors.pdf PDFs/src/opcontrol.pdf PDFs/src/pid.pdf PDFs/src/sensors.pdf doxygen/html/classcommit_1_1Commit-members.html doxygen/html/classcommit_1_1Commit.html doxygen/html/classcommit_1_1Commit.png doxygen/html/dir_49e56c817e5e54854c35e136979f97ca.html doxygen/html/hierarchy.html doxygen/html/md_README.html doxygen/html/pages.html doxygen/html/search/classes_7.html doxygen/html/search/classes_7.js doxygen/html/search/pages_0.html doxygen/html/search/pages_0.js doxygen/latex/classcommit_1_1Commit.eps doxygen/latex/classcommit_1_1Commit.tex doxygen/latex/hierarchy.tex doxygen/latex/md_README.tex doxygen/latex/refman.aux doxygen/latex/refman.idx doxygen/latex/refman.pdf doxygen/latex/refman.toc pdfMaker.sh Files modified:  Doxyfile doxygen/html/API_8h_source.html doxygen/html/annotated.html doxygen/html/classes.html doxygen/html/debug_8hpp_source.html doxygen/html/drive_8hpp_source.html doxygen/html/gyro_8hpp_source.html doxygen/html/lift_8hpp_source.html doxygen/html/menudata.js doxygen/html/motors_8hpp_source.html doxygen/html/namespacedrive.html doxygen/html/namespacedrive_1_1accel.html doxygen/html/namespacelift.html doxygen/html/namespacemembers.html doxygen/html/namespacemembers_func.html doxygen/html/namespacemembers_vars.html doxygen/html/namespacemotors_1_1slew.html doxygen/html/namespacepid.html doxygen/html/namespacesensors.html doxygen/html/pid_8hpp_source.html doxygen/html/search/all_11.js doxygen/html/search/all_12.js doxygen/html/search/all_13.js doxygen/html/search/all_15.js doxygen/html/search/all_16.js doxygen/html/search/all_3.js doxygen/html/search/all_7.js doxygen/html/search/all_9.js doxygen/html/search/all_c.js doxygen/html/search/classes_1.js doxygen/html/search/classes_2.js doxygen/html/search/classes_3.js doxygen/html/search/classes_4.js doxygen/html/search/classes_5.js doxygen/html/search/classes_6.js doxygen/html/search/functions_10.js doxygen/html/search/functions_11.js doxygen/html/search/functions_14.js doxygen/html/search/searchdata.js doxygen/html/search/variables_2.js doxygen/html/search/variables_4.js doxygen/html/search/variables_6.js doxygen/html/search/variables_9.js doxygen/html/sensors_8hpp_source.html doxygen/latex/annotated.tex doxygen/latex/namespacedrive.tex doxygen/latex/namespacedrive_1_1accel.tex doxygen/latex/namespacelift.tex doxygen/latex/namespacemotors_1_1slew.tex doxygen/latex/namespacepid.tex doxygen/latex/namespacesensors.tex doxygen/latex/refman.tex \n Commit: cd0edb617d6aaf77e1656bf91acbc1f307d4fbcd\nDate: Sat Jun 17 18:41:40 2017 -0400\nAuthor: iuyte \nDescription:\nStarted with doxygen\nFiles added:  Doxyfile doxygen/html/API_8h.html doxygen/html/API_8h_source.html doxygen/html/annotated.html doxygen/html/bc_s.png doxygen/html/bdwn.png doxygen/html/classes.html doxygen/html/classgyro_1_1drive-members.html doxygen/html/classgyro_1_1drive.html doxygen/html/classsensors_1_1gyro__t-members.html doxygen/html/classsensors_1_1gyro__t.html doxygen/html/closed.png doxygen/html/debug_8hpp_source.html doxygen/html/dir_68267d1309a1af8e8297ef4c3efbcdba.html doxygen/html/dir_d44c64559bbebec7f509842c48db8b23.html doxygen/html/doc.png doxygen/html/doxygen.css doxygen/html/doxygen.png doxygen/html/drive_8hpp_source.html doxygen/html/dynsections.js doxygen/html/files.html doxygen/html/folderclosed.png doxygen/html/folderopen.png doxygen/html/functions.html doxygen/html/functions_func.html doxygen/html/functions_vars.html doxygen/html/globals.html doxygen/html/globals_defs.html doxygen/html/globals_func.html doxygen/html/globals_type.html doxygen/html/gyro_8hpp_source.html doxygen/html/index.html doxygen/html/jquery.js doxygen/html/lift_8hpp_source.html doxygen/html/main_8h.html doxygen/html/main_8h_source.html doxygen/html/menu.js doxygen/html/menudata.js doxygen/html/motors_8hpp_source.html doxygen/html/namespacedebug.html doxygen/html/namespacedrive.html doxygen/html/namespacedrive_1_1accel.html doxygen/html/namespacelift.html doxygen/html/namespacemembers.html doxygen/html/namespacemembers_enum.html doxygen/html/namespacemembers_func.html doxygen/html/namespacemembers_vars.html doxygen/html/namespacemotors.html doxygen/html/namespacemotors_1_1slew.html doxygen/html/namespacepid.html doxygen/html/namespaces.html doxygen/html/namespacesensors.html doxygen/html/nav_f.png doxygen/html/nav_g.png doxygen/html/nav_h.png doxygen/html/open.png doxygen/html/pid_8hpp_source.html doxygen/html/search/all_0.html doxygen/html/search/all_0.js doxygen/html/search/all_1.html doxygen/html/search/all_1.js doxygen/html/search/all_10.html doxygen/html/search/all_10.js doxygen/html/search/all_11.html doxygen/html/search/all_11.js doxygen/html/search/all_12.html doxygen/html/search/all_12.js doxygen/html/search/all_13.html doxygen/html/search/all_13.js doxygen/html/search/all_14.html doxygen/html/search/all_14.js doxygen/html/search/all_15.html doxygen/html/search/all_15.js doxygen/html/search/all_16.html doxygen/html/search/all_16.js doxygen/html/search/all_17.html doxygen/html/search/all_17.js doxygen/html/search/all_18.html doxygen/html/search/all_18.js doxygen/html/search/all_19.html doxygen/html/search/all_19.js doxygen/html/search/all_2.html doxygen/html/search/all_2.js doxygen/html/search/all_3.html doxygen/html/search/all_3.js doxygen/html/search/all_4.html doxygen/html/search/all_4.js doxygen/html/search/all_5.html doxygen/html/search/all_5.js doxygen/html/search/all_6.html doxygen/html/search/all_6.js doxygen/html/search/all_7.html doxygen/html/search/all_7.js doxygen/html/search/all_8.html doxygen/html/search/all_8.js doxygen/html/search/all_9.html doxygen/html/search/all_9.js doxygen/html/search/all_a.html doxygen/html/search/all_a.js doxygen/html/search/all_b.html doxygen/html/search/all_b.js doxygen/html/search/all_c.html doxygen/html/search/all_c.js doxygen/html/search/all_d.html doxygen/html/search/all_d.js doxygen/html/search/all_e.html doxygen/html/search/all_e.js doxygen/html/search/all_f.html doxygen/html/search/all_f.js doxygen/html/search/classes_0.html doxygen/html/search/classes_0.js doxygen/html/search/classes_1.html doxygen/html/search/classes_1.js doxygen/html/search/classes_2.html doxygen/html/search/classes_2.js doxygen/html/search/classes_3.html doxygen/html/search/classes_3.js doxygen/html/search/classes_4.html doxygen/html/search/classes_4.js doxygen/html/search/classes_5.html doxygen/html/search/classes_5.js doxygen/html/search/classes_6.html doxygen/html/search/classes_6.js doxygen/html/search/close.png doxygen/html/search/defines_0.html doxygen/html/search/defines_0.js doxygen/html/search/defines_1.html doxygen/html/search/defines_1.js doxygen/html/search/defines_2.html doxygen/html/search/defines_2.js doxygen/html/search/defines_3.html doxygen/html/search/defines_3.js doxygen/html/search/defines_4.html doxygen/html/search/defines_4.js doxygen/html/search/defines_5.html doxygen/html/search/defines_5.js doxygen/html/search/defines_6.html doxygen/html/search/defines_6.js doxygen/html/search/defines_7.html doxygen/html/search/defines_7.js doxygen/html/search/defines_8.html doxygen/html/search/defines_8.js doxygen/html/search/defines_9.html doxygen/html/search/defines_9.js doxygen/html/search/defines_a.html doxygen/html/search/defines_a.js doxygen/html/search/enums_0.html doxygen/html/search/enums_0.js doxygen/html/search/files_0.html doxygen/html/search/files_0.js doxygen/html/search/files_1.html doxygen/html/search/files_1.js doxygen/html/search/functions_0.html doxygen/html/search/functions_0.js doxygen/html/search/functions_1.html doxygen/html/search/functions_1.js doxygen/html/search/functions_10.html doxygen/html/search/functions_10.js doxygen/html/search/functions_11.html doxygen/html/search/functions_11.js doxygen/html/search/functions_12.html doxygen/html/search/functions_12.js doxygen/html/search/functions_13.html doxygen/html/search/functions_13.js doxygen/html/search/functions_14.html doxygen/html/search/functions_14.js doxygen/html/search/functions_2.html doxygen/html/search/functions_2.js doxygen/html/search/functions_3.html doxygen/html/search/functions_3.js doxygen/html/search/functions_4.html doxygen/html/search/functions_4.js doxygen/html/search/functions_5.html doxygen/html/search/functions_5.js doxygen/html/search/functions_6.html doxygen/html/search/functions_6.js doxygen/html/search/functions_7.html doxygen/html/search/functions_7.js doxygen/html/search/functions_8.html doxygen/html/search/functions_8.js doxygen/html/search/functions_9.html doxygen/html/search/functions_9.js doxygen/html/search/functions_a.html doxygen/html/search/functions_a.js doxygen/html/search/functions_b.html doxygen/html/search/functions_b.js doxygen/html/search/functions_c.html doxygen/html/search/functions_c.js doxygen/html/search/functions_d.html doxygen/html/search/functions_d.js doxygen/html/search/functions_e.html doxygen/html/search/functions_e.js doxygen/html/search/functions_f.html doxygen/html/search/functions_f.js doxygen/html/search/mag_sel.png doxygen/html/search/namespaces_0.html doxygen/html/search/namespaces_0.js doxygen/html/search/namespaces_1.html doxygen/html/search/namespaces_1.js doxygen/html/search/namespaces_2.html doxygen/html/search/namespaces_2.js doxygen/html/search/namespaces_3.html doxygen/html/search/namespaces_3.js doxygen/html/search/namespaces_4.html doxygen/html/search/namespaces_4.js doxygen/html/search/nomatches.html doxygen/html/search/search.css doxygen/html/search/search.js doxygen/html/search/search_l.png doxygen/html/search/search_m.png doxygen/html/search/search_r.png doxygen/html/search/searchdata.js doxygen/html/search/typedefs_0.html doxygen/html/search/typedefs_0.js doxygen/html/search/typedefs_1.html doxygen/html/search/typedefs_1.js doxygen/html/search/typedefs_2.html doxygen/html/search/typedefs_2.js doxygen/html/search/typedefs_3.html doxygen/html/search/typedefs_3.js doxygen/html/search/typedefs_4.html doxygen/html/search/typedefs_4.js doxygen/html/search/typedefs_5.html doxygen/html/search/typedefs_5.js doxygen/html/search/typedefs_6.html doxygen/html/search/typedefs_6.js doxygen/html/search/typedefs_7.html doxygen/html/search/typedefs_7.js doxygen/html/search/variables_0.html doxygen/html/search/variables_0.js doxygen/html/search/variables_1.html doxygen/html/search/variables_1.js doxygen/html/search/variables_2.html doxygen/html/search/variables_2.js doxygen/html/search/variables_3.html doxygen/html/search/variables_3.js doxygen/html/search/variables_4.html doxygen/html/search/variables_4.js doxygen/html/search/variables_5.html doxygen/html/search/variables_5.js doxygen/html/search/variables_6.html doxygen/html/search/variables_6.js doxygen/html/search/variables_7.html doxygen/html/search/variables_7.js doxygen/html/search/variables_8.html doxygen/html/search/variables_8.js doxygen/html/search/variables_9.html doxygen/html/search/variables_9.js doxygen/html/search/variables_a.html doxygen/html/search/variables_a.js doxygen/html/search/variables_b.html doxygen/html/search/variables_b.js doxygen/html/search/variables_c.html doxygen/html/search/variables_c.js doxygen/html/search/variables_d.html doxygen/html/search/variables_d.js doxygen/html/search/variables_e.html doxygen/html/search/variables_e.js doxygen/html/sensors_8hpp_source.html doxygen/html/splitbar.png doxygen/html/structdrive_1_1side__t-members.html doxygen/html/structdrive_1_1side__t.html doxygen/html/structlift_1_1side__t-members.html doxygen/html/structlift_1_1side__t.html doxygen/html/structmotor__t-members.html doxygen/html/structmotor__t.html doxygen/html/structsensors_1_1button__t-members.html doxygen/html/structsensors_1_1button__t.html doxygen/html/structsensors_1_1pot__t-members.html doxygen/html/structsensors_1_1pot__t.html doxygen/html/structsensors_1_1quad__t-members.html doxygen/html/structsensors_1_1quad__t.html doxygen/html/structsensors_1_1sonic__t-members.html doxygen/html/structsensors_1_1sonic__t.html doxygen/html/sync_off.png doxygen/html/sync_on.png doxygen/html/tab_a.png doxygen/html/tab_b.png doxygen/html/tab_h.png doxygen/html/tab_s.png doxygen/html/tabs.css doxygen/latex/API_8h.tex doxygen/latex/Makefile doxygen/latex/annotated.tex doxygen/latex/classgyro_1_1drive.tex doxygen/latex/classsensors_1_1gyro__t.tex doxygen/latex/doxygen.sty doxygen/latex/files.tex doxygen/latex/main_8h.tex doxygen/latex/namespacedebug.tex doxygen/latex/namespacedrive.tex doxygen/latex/namespacedrive_1_1accel.tex doxygen/latex/namespacelift.tex doxygen/latex/namespacemotors.tex doxygen/latex/namespacemotors_1_1slew.tex doxygen/latex/namespacepid.tex doxygen/latex/namespaces.tex doxygen/latex/namespacesensors.tex doxygen/latex/refman.tex doxygen/latex/structdrive_1_1side__t.tex doxygen/latex/structlift_1_1side__t.tex doxygen/latex/structmotor__t.tex doxygen/latex/structsensors_1_1button__t.tex doxygen/latex/structsensors_1_1pot__t.tex doxygen/latex/structsensors_1_1quad__t.tex doxygen/latex/structsensors_1_1sonic__t.tex \n Commit: de91c1e5bc6865b76610d5553a9d08682ab0adb7\nDate: Sat Jun 17 18:14:26 2017 -0400\nAuthor: iuyte \nDescription:\nGyro work\nFiles added:  include/gyro.hpp src/gyro.cpp Files modified:  .clang-format vim.sh \n Commit: 48aa05152ad553d95e8c0f11b660b1272e3d76d2\nDate: Sat Jun 17 15:33:32 2017 -0400\nAuthor: iuyte \nDescription:\nFixed displaying of pycache files in website\nFiles modified:  docs/cleanuphelp.py \n Commit: f150000d3f0f6c8c12fd2df44bb7f7551010c103\nDate: Sat Jun 17 15:16:17 2017 -0400\nAuthor: iuyte \nDescription:\nFixed headers\nFiles modified:  include/debug.hpp include/lift.hpp src/lift.cpp \n Commit: ebd11bb1efa8334eaffb4a8333744cfd35968436\nDate: Sat Jun 17 14:50:36 2017 -0400\nAuthor: iuyte \nDescription:\nAdded lift::to function, using a simple loop to go to a desired value\nFiles modified:  include/lift.hpp src/lift.cpp \n Commit: f9e6c7dcf36d11c553177ff76b8e9dc39a156bf0\nDate: Sat Jun 17 11:41:27 2017 -0400\nAuthor: iuyte \nDescription:\nAdded a gyro to the robot\nFiles modified:  .gitignore docs/cleanuphelp.py include/sensors.hpp src/sensors.cpp tools/commit.sh \n Commit: d30be5271eb69e1182303355d09919a9c0e09b97\nDate: Fri Jun 16 19:17:40 2017 -0400\nAuthor: iuyte \nDescription:\nTrying to ignore annoying vim temporary files in commits\nFiles modified:  .gitignore docs/cleanuphelp.py \n Commit: 5177e894760f89e036182ec02e233f888c20acc6\nDate: Fri Jun 16 19:08:58 2017 -0400\nAuthor: iuyte \nDescription:\nadded lift, sensor for lift\nFiles added:  include/lift.hpp src/lift.cpp vim.sh Files modified:  include/debug.hpp include/pid.hpp include/sensors.hpp src/sensors.cpp \n Commit: 0da38ad7b2424ca3c77b6c89fb93e1f49a8d913d\nDate: Fri Jun 16 18:13:38 2017 -0400\nAuthor: iuyte \nDescription:\nremoved rerun (won't be accurate enough), will re-implement if it proves to be useful\nFiles modified:  include/debug.hpp include/main.h src/auto.cpp src/opcontrol.cpp Files deleted:  include/rerun.hpp src/rerun.cpp \n Commit: f3580040542f040e229136b2462cc61fce788b97\nDate: Fri Jun 16 18:07:59 2017 -0400\nAuthor: iuyte \nDescription:\nRedid style\nFiles modified:  .clang-format include/API.h include/debug.hpp include/drive.hpp include/motors.hpp include/pid.hpp include/rerun.hpp include/sensors.hpp src/debug.cpp src/drive.cpp src/motors.cpp src/pid.cpp src/rerun.cpp src/sensors.cpp \n Commit: f62df479c07d11dbabe9ce88596aed611ea69809\nDate: Fri Jun 9 22:27:45 2017 -0400\nAuthor: iuyte \nDescription:\nStyle fix in sensors.hpp and practice fix in pid.cpp\nFiles modified:  include/sensors.hpp src/pid.cpp \n Commit: 7e770b10cd3a43ac3f1fa9a9c8bc98c38e1ab109\nDate: Fri Jun 9 15:57:13 2017 -0400\nAuthor: iuyte \nDescription:\nfixed bad link\nFiles modified:  .gitignore docs/cleanup.py docs/cleanuphelp.py docs/commit.py \n Commit: 045f79181af1776ad59c720e3e26d75f1bc284eb\nDate: Thu Jun 8 21:16:23 2017 -0400\nAuthor: iuyte \nDescription:\nAssignment optimizations in motors.cpp and style fixes elsewhere\nFiles modified:  include/motors.hpp src/motors.cpp src/sensors.cpp \n Commit: 383155846c81dc9d00f6ceca74a42055da09791c\nDate: Thu Jun 8 21:10:40 2017 -0400\nAuthor: iuyte \nDescription:\nDelete .opcontrol.cpp.swp\n Commit: 9b7ebe8db5860c13f596a2f62f2c6868bdd4634e\nDate: Thu Jun 8 19:23:03 2017 -0400\nAuthor: iuyte \nDescription:\nfixed typo and removed unnessecary include\nFiles modified:  .ycm_extra_conf.py include/sensors.hpp src/pid.cpp \n Commit: 9941f2826110ccab816b7d91cab4e82ddc5dc153\nDate: Thu Jun 8 18:02:47 2017 -0400\nAuthor: iuyte \nDescription:\nSmall bug fixes\nFiles modified:  include/sensors.hpp src/rerun.cpp src/sensors.cpp \n Commit: 1cece1fac3a0833019de68e5f90ae11614c95830\nDate: Tue Jun 6 22:08:40 2017 -0400\nAuthor: iuyte \nDescription:\nRerun and pid work\nFiles modified:  include/pid.hpp include/rerun.hpp src/pid.cpp src/rerun.cpp \n Commit: 338e4f71b7cb81e724aa3d1052745d87689d5502\nDate: Tue Jun 6 21:25:54 2017 -0400\nAuthor: iuyte \nDescription:\nProject management fixing\nFiles added:  .ycm_extra_conf.py Files modified:  .gitignore \n Commit: 64aaf8dbc4881e414a67dc0311dfe7f7d7ff0c9d\nDate: Tue Jun 6 21:18:49 2017 -0400\nAuthor: iuyte \nDescription:\nAdded namespace, class, function, variable and constant comments describing funtion of them\nFiles modified:  include/debug.hpp include/drive.hpp include/motors.hpp include/pid.hpp include/rerun.hpp include/sensors.hpp src/debug.cpp src/motors.cpp src/pid.cpp \n Commit: 25545ec9c215f06b15941218473a8fa3cbcec1f5\nDate: Tue Jun 6 17:28:54 2017 -0400\nAuthor: iuyte \nDescription:\nadded file boilerplates\nFiles modified:  include/debug.hpp include/drive.hpp include/motors.hpp include/pid.hpp include/rerun.hpp include/sensors.hpp src/auto.cpp src/debug.cpp src/drive.cpp src/init.cpp src/motors.cpp src/opcontrol.cpp src/pid.cpp src/rerun.cpp src/sensors.cpp \n Commit: b29c8f1ab9c9dde1ff94cc2a393d4ef8553d08e7\nDate: Tue Jun 6 07:09:28 2017 -0400\nAuthor: iuyte \nDescription:\nStarted commenting functions, added switching between accel and tank drive\nFiles modified:  include/drive.hpp src/drive.cpp src/opcontrol.cpp tools/commit.sh \n Commit: 1d3446b2988038b8fedf4f86767eccc4f62c06c2\nDate: Mon Jun 5 15:28:15 2017 -0400\nAuthor: iuyte \nDescription:\nsmall cleanup portions\nFiles modified:  include/drive.hpp include/motors.hpp include/sensors.hpp src/drive.cpp src/motors.cpp src/pid.cpp src/rerun.cpp src/sensors.cpp \n Commit: 5cee757caf15f96f1b1a463907b158247909ef50\nDate: Sun Jun 4 16:07:52 2017 -0400\nAuthor: iuyte \nDescription:\nRemoved trailing \"\"\" in main.css\nFiles modified:  docs/style.css \n Commit: 4e76d380328a88557d84a71aa1d8296faa5d2847\nDate: Sun Jun 4 16:01:45 2017 -0400\nAuthor: iuyte \nDescription:\nRe-added .clang-format for style that had dissappeared\nFiles added:  .clang-format \n Commit: 21cd9813eb4ae0f741ccb9e96e0095e68b1aef8d\nDate: Sun Jun 4 15:21:26 2017 -0400\nAuthor: iuyte \nDescription:\nChanged standard to C++14 in Makefile\nFiles modified:  Makefile \n Commit: d3ee336a50bd391ff80cb4535f143092c62386e9\nDate: Sun Jun 4 14:12:12 2017 -0400\nAuthor: iuyte \nDescription:\nChanged project structure\nFiles added:  Makefile common.mk firmware/STM32F10x.ld firmware/cortex.ld firmware/libpros.a firmware/uniflash.jar include/API.h include/debug.hpp include/drive.hpp include/main.h include/motors.hpp include/pid.hpp include/rerun.hpp include/sensors.hpp project.pros src/Makefile src/auto.cpp src/debug.cpp src/drive.cpp src/init.cpp src/motors.cpp src/opcontrol.cpp src/pid.cpp src/rerun.cpp src/sensors.cpp Files modified:  tools/commit.sh Files deleted:  cpls/.clang-format cpls/Makefile cpls/common.mk cpls/firmware/STM32F10x.ld cpls/firmware/cortex.ld cpls/firmware/libpros.a cpls/firmware/uniflash.jar cpls/include/API.h cpls/include/debug.hpp cpls/include/drive.hpp cpls/include/main.h cpls/include/motors.hpp cpls/include/pid.hpp cpls/include/rerun.hpp cpls/include/sensors.hpp cpls/project.pros cpls/src/Makefile cpls/src/auto.cpp cpls/src/debug.cpp cpls/src/drive.cpp cpls/src/init.cpp cpls/src/motors.cpp cpls/src/opcontrol.cpp cpls/src/pid.cpp cpls/src/rerun.cpp cpls/src/sensors.cpp miniRerun/Makefile miniRerun/common.mk miniRerun/firmware/STM32F10x.ld miniRerun/firmware/cortex.ld miniRerun/firmware/firmware/STM32F10x.ld miniRerun/firmware/firmware/cortex.ld miniRerun/firmware/firmware/uniflash.jar miniRerun/firmware/libpros.a miniRerun/firmware/uniflash.jar miniRerun/include/API.h miniRerun/include/main.h miniRerun/include/motors.h miniRerun/include/pid.h miniRerun/include/rerun.h miniRerun/include/sensors.h miniRerun/project.pros miniRerun/src/Makefile miniRerun/src/auto.c miniRerun/src/drive.c miniRerun/src/init.c miniRerun/src/opcontrol.c miniRerun/src/pid.c miniRerun/src/rerun.c miniRerun/src/sensors.c tools/compile.py tools/compile.sh \n Commit: 669b18131ee82bf3a8cddadb76c56823c0c1b89d\nDate: Sat Jun 3 12:16:02 2017 -0400\nAuthor: iuyte \nDescription:\nAdded PID drive support in accelerometer drive\nFiles modified:  .gitignore cpls/src/drive.cpp cpls/src/sensors.cpp \n Commit: 9b91d35702bfc3b9aee017a9408854015aa101f1\nDate: Sat Jun 3 10:55:21 2017 -0400\nAuthor: iuyte \nDescription:\nModified cleanuphelp.py such that the webpage no longer shows it's own files under files modified\nFiles modified:  docs/cleanuphelp.py \n Commit: a56487993a04a72e7e1097dd21fc4cbe14b770c6\nDate: Sat Jun 3 10:44:46 2017 -0400\nAuthor: iuyte \nDescription:\nredid project .clang-format and applied changes\nFiles added:  cpls/.clang-format Files modified:  cpls/include/API.h cpls/include/debug.hpp cpls/include/drive.hpp cpls/include/main.h cpls/include/pid.hpp cpls/include/sensors.hpp cpls/src/debug.cpp cpls/src/drive.cpp cpls/src/motors.cpp cpls/src/pid.cpp cpls/src/rerun.cpp cpls/src/sensors.cpp Files deleted:  cpls/.atom-build.yml \n Commit: 5c38955616284fbf8d6abdd1db84729ef6f984a3\nDate: Thu Jun 1 20:25:54 2017 -0400\nAuthor: iuyte \nDescription:\ndeleted odd file\n Commit: ce0c7b71920fb8e8e527e35dc12102fdb0362f89\nDate: Tue May 30 19:07:07 2017 -0400\nAuthor: iuyte \nDescription:\nChanges include *.hpp to include ../include/*.hpp, also fixed extra iteration of slewing loop\nFiles modified:  cpls/src/auto.cpp cpls/src/debug.cpp cpls/src/drive.cpp cpls/src/init.cpp cpls/src/motors.cpp cpls/src/opcontrol.cpp cpls/src/pid.cpp cpls/src/rerun.cpp cpls/src/sensors.cpp \n Commit: 76ef13d5dd85d656a4862c58e2f6f8e8360f97ba\nDate: Sun May 28 20:29:42 2017 -0400\nAuthor: iuyte \nDescription:\nreorganized commiting scripts, system, files\nFiles added:  docs/main.js docs/style.css tools/commit.sh tools/compile.py tools/compile.sh Files modified:  docs/cleanuphelp.py Files deleted:  commit.sh compile.py compile.sh \n Commit: 56fe16f613509762b984328b03f6f4561e23d3ae\nDate: Sun May 28 20:05:47 2017 -0400\nAuthor: iuyte \nDescription:\nFixed minor logical optimization and removed unnecessary include\nFiles modified:  cpls/include/sensors.hpp cpls/src/opcontrol.cpp \n Commit: 99417e376e0be846904cb0f59630aae89b425db4\nDate: Sun May 28 18:03:27 2017 -0400\nAuthor: iuyte \nDescription:\nadded ability to use accelerometers in joysticks to drive\nFiles modified:  cpls/include/drive.hpp cpls/src/drive.cpp cpls/src/opcontrol.cpp \n Commit: 8727970b7682ebbdf1f81fc1f4f1ef891718065d\nDate: Sun May 28 17:35:03 2017 -0400\nAuthor: iuyte \nDescription:\nadded license\nFiles added:  LICENSE \n Commit: 763e1053099ae354a8ae936975b3d8140ccc7d17\nDate: Sat May 27 20:17:05 2017 -0400\nAuthor: iuyte \nDescription:\nDeleted odd file from beautification script error\nFiles deleted:  cpls/include/.atom-beautify.motors.hpp \n Commit: 11c20785e5a72e729e541ea92f2ec137c5680bf9\nDate: Sat May 27 20:13:17 2017 -0400\nAuthor: iuyte \nDescription:\nFixed bad practice\nFiles added:  cpls/include/.atom-beautify.motors.hpp Files modified:  cpls/include/motors.hpp cpls/src/motors.cpp \n Commit: 4803fd41216658a77c013396da55078223487f48\nDate: Sat May 27 20:07:01 2017 -0400\nAuthor: iuyte \nDescription:\nFinally got slewing working\nFiles modified:  cpls/include/motors.hpp cpls/src/drive.cpp cpls/src/init.cpp cpls/src/motors.cpp \n Commit: 842d2831621a447128e6b9a5d1f91c622adcd54f\nDate: Sat May 27 15:51:42 2017 -0400\nAuthor: iuyte \nDescription:\nremoved unnecessary files\nFiles deleted:  commit.py projects.txt \n Commit: 3b0397b3396f3ca115306ffd5dbaa5be6ca8eaa2\nDate: Sat May 27 15:28:54 2017 -0400\nAuthor: iuyte \nDescription:\nmade code runnable, added to autonomous\nFiles modified:  compile.sh cpls/include/sensors.hpp cpls/src/auto.cpp cpls/src/sensors.cpp \n Commit: 79f4d3b5cc8386e7b32fda2ff67380cf0bd2da33\nDate: Sat May 27 15:16:41 2017 -0400\nAuthor: iuyte \nDescription:\nfixed compile.py\nFiles modified:  compile.sh \n Commit: 081320b57acc357354a818958a2cc026ffe999f9\nDate: Sat May 27 14:40:37 2017 -0400\nAuthor: iuyte \nDescription:\nadded rerun::enabled bool, changed motors::set() to side_t::::set() in drive\nFiles modified:  cpls/include/rerun.hpp cpls/src/drive.cpp cpls/src/opcontrol.cpp cpls/src/rerun.cpp \n Commit: 76d1c5a87d1aa32b22828a89d503ec4ac9817bba\nDate: Sat May 27 07:33:22 2017 -0400\nAuthor: iuyte \nDescription:\nAdded class for ultrasonics\nFiles modified:  cpls/include/sensors.hpp cpls/src/sensors.cpp \n Commit: 42620000dab121220e5be649854a44cb44b15e41\nDate: Tue May 23 01:02:26 2017 -0400\nAuthor: iuyte \nDescription:\nslewing fix and actually enabling it in init.cpp\nFiles modified:  cpls/include/motors.hpp cpls/src/init.cpp \n Commit: 91666d0d582b3f1c99d5b9a303c94064a114df61\nDate: Tue May 23 01:01:40 2017 -0400\nAuthor: iuyte \nDescription:\nMore sensor classes\nFiles modified:  cpls/include/sensors.hpp cpls/src/sensors.cpp \n Commit: d9c726384d0e4d25070110ccb8c0d22a5013ea29\nDate: Mon May 22 01:07:33 2017 -0400\nAuthor: iuyte \nDescription:\nmodified compile.py to automatically detect which folders are projects and compiles them on the running of my commitscript\nFiles modified:  compile.py cpls/include/drive.hpp cpls/include/motors.hpp cpls/include/sensors.hpp cpls/src/drive.cpp cpls/src/motors.cpp cpls/src/pid.cpp cpls/src/sensors.cpp \n Commit: 264671714dfe84d7c6b5829d5fecd2491c723b84\nDate: Sun May 21 22:34:53 2017 -0400\nAuthor: iuyte \nDescription:\nfixing commit.sh\nFiles modified:  commit.sh \n Commit: 94d9f123dbeb3ead323be8e3353cef4c189808db\nDate: Sun May 21 22:24:59 2017 -0400\nAuthor: iuyte \nDescription:\nfixing\nFiles modified:  commit.sh \n Commit: debbb02eb84ee365b491c89577c67b0170c22655\nDate: Sun May 21 22:23:40 2017 -0400\nAuthor: iuyte \nDescription:\nchanges to  Commit: 8b456fda3b22c38a7aa2a4b44a2f3a50e12b19fa\nDate: Sun May 21 21:15:55 2017 -0400\nAuthor: iuyte \nDescription:\nFixed minor ineffeciency\nFiles modified:  cpls/include/sensors.hpp \n Commit: fd344715a2b2ba12a1d3e3d5b544f0faab387165\nDate: Sun May 21 18:44:18 2017 -0400\nAuthor: iuyte \nDescription:\nRenamed files to .hpp\nFiles added:  cpls/include/debug.hpp cpls/include/drive.hpp cpls/include/motors.hpp cpls/include/pid.hpp cpls/include/rerun.hpp cpls/include/sensors.hpp Files modified:  commit.sh cpls/include/main.h cpls/src/debug.cpp cpls/src/motors.cpp cpls/src/pid.cpp Files deleted:  cpls/include/debug.h cpls/include/drive.h cpls/include/motors.h cpls/include/pid.h cpls/include/rerun.h cpls/include/sensors.h \n Commit: 5853c9ea4748da3bfccd16a8da5b47d10f950ccf\nDate: Sun May 21 18:37:09 2017 -0400\nAuthor: iuyte \nDescription:\nadopted new style\nFiles modified:  cpls/include/API.h cpls/include/debug.h cpls/include/drive.h cpls/include/main.h cpls/include/motors.h cpls/include/pid.h cpls/include/rerun.h cpls/include/sensors.h cpls/src/debug.cpp cpls/src/drive.cpp cpls/src/init.cpp cpls/src/motors.cpp cpls/src/opcontrol.cpp cpls/src/pid.cpp cpls/src/rerun.cpp cpls/src/sensors.cpp Files deleted:  cpls/log.txt \n Commit: 1988c03883b5c1b5d06d0088412e5e0a03f84f93\nDate: Sat May 20 18:37:08 2017 -0400\nAuthor: iuyte \nDescription:\nRemoved redundancy\nFiles modified:  docs/document.sh \n Commit: 66b65daa43257108774874a428702a2c606dab3e\nDate: Sat May 20 18:36:37 2017 -0400\nAuthor: iuyte \nDescription:\nFixing json prettification\nFiles modified:  docs/document.sh \n Commit: 916a17d9938257639eab28e8ad7e5bd2a0290f8e\nDate: Sat May 20 18:35:06 2017 -0400\nAuthor: iuyte \nDescription:\nAdded json prettifier to the auto-document script\nFiles modified:  docs/document.sh \n Commit: ad829d49547909dfe37b34eb842385d4c585bc3f\nDate: Sat May 20 18:16:10 2017 -0400\nAuthor: iuyte \nDescription:\ncreated  Commit: 470082234b4eef9f8be84ecff3a66a1f96fb09c6\nDate: Sat May 20 18:06:14 2017 -0400\nAuthor: iuyte \nDescription:\nRerun work\nFiles modified:  cpls/include/rerun.h cpls/src/rerun.cpp \n Commit: cd8d13ebf494e94fcef62cb7f80f8063c13a8dfc\nDate: Sun May 7 21:12:31 2017 -0400\nAuthor: iuyte \nDescription:\nRe-added slew functionality, hopeful of success.\nFiles added:  .gitignore Files modified:  cpls/include/motors.h cpls/src/motors.cpp \n Commit: 104883373f900eab9cb0d02ac08fcacd5f61ff98\nDate: Sun May 7 20:54:30 2017 -0400\nAuthor: iuyte \nDescription:\nFixed rerun issues, eliminated slewing (wasnt working), created debug mode to identify segfaults\nFiles added:  cpls/include/debug.h cpls/src/debug.cpp Files modified:  cpls/include/drive.h cpls/include/main.h cpls/include/motors.h cpls/include/pid.h cpls/include/rerun.h cpls/src/auto.cpp cpls/src/drive.cpp cpls/src/motors.cpp cpls/src/opcontrol.cpp cpls/src/pid.cpp cpls/src/rerun.cpp \n Commit: 976ba5da0b6d03483942e061f54fdc177b42270d\nDate: Sun May 7 17:15:54 2017 -0400\nAuthor: iuyte \nDescription:\nVarious code cleanups, abstracted to allow slewing\nFiles modified:  cpls/include/drive.h cpls/include/motors.h cpls/include/rerun.h cpls/src/drive.cpp cpls/src/init.cpp cpls/src/motors.cpp cpls/src/opcontrol.cpp cpls/src/rerun.cpp \n Commit: 70fc1ca9eeaf0abcf35dd328d0e9860068d13cd5\nDate: Sun May 7 13:38:03 2017 -0400\nAuthor: iuyte \nDescription:\nTested code, all but rerun works\nFiles modified:  cpls/include/motors.h cpls/include/sensors.h cpls/src/drive.cpp cpls/src/motors.cpp cpls/src/opcontrol.cpp cpls/src/pid.cpp cpls/src/rerun.cpp cpls/src/sensors.cpp \n Commit: 732e7e6949e5bdc83e52f215806eb411634b5f97\nDate: Sat May 6 20:20:20 2017 -0400\nAuthor: iuyte \nDescription:\nAdded rerun functionality\nFiles added:  cpls/include/rerun.h cpls/src/rerun.cpp Files modified:  cpls/include/main.h cpls/src/auto.cpp cpls/src/opcontrol.cpp \n Commit: 34b5e5bac90c3c82e07e675605384cc5fba639be\nDate: Sat May 6 17:50:59 2017 -0400\nAuthor: iuyte \nDescription:\nAdded .atom-build.yml to enable my ability to build the project with CTRL + ALT + B\nFiles added:  cpls/.atom-build.yml \n Commit: 4a4a588cc819a71bc9ecc8078227b9103063505f\nDate: Sat May 6 17:27:29 2017 -0400\nAuthor: iuyte \nDescription:\nChanged CCFLAGS:=-c -Wall $(MCUCFLAGS) -Os -ffunction-sections -fsigned-char -fomit-frame-pointer -fsingle-precision-constant to CCFLAGS:=-c -Wall $(MCUCFLAGS) -Os -ffunction-sections -fsigned-char -fomit-frame-pointer -fsingle-precision-constant -std=c++14 in common.mk because it's C++\nFiles modified:  cpls/common.mk Files deleted:  log.json \n Commit: ac55f3ec527107a9f33a6208fe27bbff117ef157\nDate: Sat May 6 17:24:47 2017 -0400\nAuthor: iuyte \nDescription:\nCreated document.sh to almost completely automate documentation process\nFiles added:  docs/document.sh \n Commit: 5529f7b01ba91e1faa74f157345161816805459e\nDate: Sat May 6 17:02:20 2017 -0400\nAuthor: iuyte \nDescription:\nAdded easier motor support, PID\nFiles added:  cpls/include/motors.h cpls/include/pid.h cpls/src/motors.cpp cpls/src/pid.cpp Files modified:  cpls/include/drive.h cpls/include/main.h cpls/include/sensors.h cpls/src/auto.cpp cpls/src/drive.cpp cpls/src/init.cpp cpls/src/opcontrol.cpp cpls/src/sensors.cpp resources/cone.png \n Commit: 5195914c6b2c4abc3c43069769756e971a47bf37\nDate: Mon May 1 19:31:59 2017 -0400\nAuthor: iuyte \nDescription:\nFixed issue with sensors namespace and begun drive.cpp\nFiles added:  cpls/src/drive.cpp log.json Files modified:  cpls/include/drive.h cpls/include/sensors.h cpls/src/sensors.cpp \n Commit: 6e9de5d912b0f6dd5c04f7743d5b2501e36a0f7d\nDate: Mon May 1 00:29:58 2017 +0400\nAuthor: iuyte \nDescription:\nHopefully fixed inclusion problem\nFiles modified:  cpls/include/sensors.h \n Commit: 76fc50bd0ab6be9ad4b23a5f0835af40ceb84c7e\nDate: Sun Apr 30 16:07:07 2017 +0400\nAuthor: Ethan Wells \nDescription:\ncreated cone image in resourses\nFiles added:  resources/cone.ipt resources/cone.png \n Commit: 772389c5ebde877dfea04a3d790b1aa46e9a886c\nDate: Sun Apr 30 10:04:25 2017 -0400\nAuthor: iuyte \nDescription:\nCreated resources folder for game resourced\nFiles added:  resources/276-5369-000 Rev2.STEP resources/VRC-InTheZone-AppendixA-042217.zip resources/VRC-InTheZone-AppendixA-FieldSpecs-042217.pdf resources/VRC-InTheZone-AppendixB-RobotSkills-042217.pdf resources/VRC-InTheZone-AppendixE-VEXU-042217.pdf resources/VRC-InTheZone-GameManual-042217.pdf resources/VRC-InTheZone-LowCostFieldOptions-042217.pdf \n Commit: f8c484c712e0be153ec6e7313e24a20ee4ff5ed3\nDate: Sun Apr 30 09:36:00 2017 -0400\nAuthor: iuyte \nDescription:\ninclusion issue, attempting to fix\nFiles added:  cpls/include/drive.h cpls/include/sensors.h cpls/src/sensors.cpp Files modified:  cpls/include/main.h cpls/src/init.cpp Files deleted:  cpls/src/include/foo.h \n Commit: 34e3091fdab1d452daa84ba195facb7ff4d1b944\nDate: Sat Apr 29 22:36:31 2017 -0400\nAuthor: iuyte \nDescription:\nnew project for C++ code, works\nFiles added:  cpls/Makefile cpls/common.mk cpls/firmware/STM32F10x.ld cpls/firmware/cortex.ld cpls/firmware/libpros.a cpls/firmware/uniflash.jar cpls/include/API.h cpls/include/main.h cpls/project.pros cpls/src/Makefile cpls/src/auto.cpp cpls/src/include/foo.h cpls/src/init.cpp cpls/src/opcontrol.cpp \n Commit: 5fffbb586454534c27646ca9692b1d8e8d7df10b\nDate: Sat Apr 29 20:29:43 2017 -0400\nAuthor: iuyte \nDescription:\nFixed PID, now works, may need tuning\nFiles modified:  miniRerun/include/main.h miniRerun/include/motors.h miniRerun/include/pid.h miniRerun/include/sensors.h miniRerun/src/auto.c miniRerun/src/drive.c miniRerun/src/init.c miniRerun/src/opcontrol.c miniRerun/src/pid.c miniRerun/src/rerun.c miniRerun/src/sensors.c \n Commit: be82604784a8a1165d4ebc89570a37ebd0219ade\nDate: Sat Apr 29 15:51:31 2017 -0400\nAuthor: iuyte \nDescription:\nChanged management of whether pid is enabled, small pid changes and now adressing the right pid index in replay\nFiles modified:  miniRerun/include/pid.h miniRerun/src/init.c miniRerun/src/pid.c miniRerun/src/rerun.c \n Commit: 04e01af7a61ee6641485896b94720d2e378ac01d\nDate: Sat Apr 29 13:28:41 2017 -0400\nAuthor: iuyte \nDescription:\nSimplified rerun to use structs rather than text, making it easier to parse. Added PID draft to support rerun\nFiles added:  miniRerun/include/pid.h miniRerun/src/pid.c Files modified:  miniRerun/include/main.h miniRerun/include/motors.h miniRerun/include/rerun.h miniRerun/src/drive.c miniRerun/src/init.c miniRerun/src/rerun.c \n Commit: 29c55dc4d02c2e4bc634a3833b475ea5bef1fc10\nDate: Sun Apr 23 21:30:44 2017 -0400\nAuthor: iuyte \nDescription:\nAdded delay in replay function\nFiles modified:  miniRerun/src/rerun.c \n Commit: a687907d49d9f39b249b3e2a6b43a8bb96101664\nDate: Sun Apr 23 13:29:04 2017 +0400\nAuthor: Ethan Wells \nDescription:\nAutomatic rerun enabling and disabling in opcontrol\nFiles modified:  miniRerun/src/opcontrol.c \n Commit: 2955d9f2a3245a746ee18efe4fada6e14d26038a\nDate: Sun Apr 23 07:44:19 2017 +0400\nAuthor: Ethan Wells \nDescription:\nAdapted code for 4 motor drive\nFiles added:  miniRerun/src/drive.c Files modified:  miniRerun/include/motors.h miniRerun/include/sensors.h miniRerun/src/opcontrol.c miniRerun/src/rerun.c miniRerun/src/sensors.c \n Commit: 8810eb12fe271f730590b6b4e9ae9ae0517a7f4f\nDate: Sat Apr 22 23:20:34 2017 +0400\nAuthor: Ethan Wells \nDescription:\nFixed still-broken links in webpage generator\nFiles modified:  docs/cleanuphelp.py \n Commit: 5f698f0f91d2580c141d7af06e842dd93cf41081\nDate: Sat Apr 22 23:14:16 2017 +0400\nAuthor: Ethan Wells \nDescription:\nfixed links in webpage generator script\nFiles modified:  docs/cleanuphelp.py \n Commit: fe3ffb19aa4921bb9058700e703e7872e620fdfa\nDate: Sat Apr 22 23:02:51 2017 +0400\nAuthor: Ethan Wells \nDescription:\nfixed inclusion issue with standard header guards\nFiles modified:  miniRerun/include/motors.h miniRerun/include/rerun.h miniRerun/include/sensors.h \n Commit: 5ad70ac34a2a80d0bb747b261d27930012ea0f68\nDate: Sat Apr 22 22:49:07 2017 +0400\nAuthor: Ethan Wells \nDescription:\nadded my webpage creater script in docs, generated log\nFiles added:  docs/cleanup.py docs/cleanuphelp.py docs/commit.py docs/index.html docs/log.json docs/log.txt \n Commit: 033b01a38ae59bbe1b8faa8ff4c366bdc2832629\nDate: Sat Apr 22 22:44:42 2017 +0400\nAuthor: Ethan Wells \nDescription:\nCreated 2 motor pushbot rerun, modified README.md to be more descriptive\nFiles added:  miniRerun/Makefile miniRerun/common.mk miniRerun/firmware/STM32F10x.ld miniRerun/firmware/cortex.ld miniRerun/firmware/firmware/STM32F10x.ld miniRerun/firmware/firmware/cortex.ld miniRerun/firmware/firmware/uniflash.jar miniRerun/firmware/libpros.a miniRerun/firmware/uniflash.jar miniRerun/include/API.h miniRerun/include/main.h miniRerun/include/motors.h miniRerun/include/rerun.h miniRerun/include/sensors.h miniRerun/project.pros miniRerun/src/Makefile miniRerun/src/auto.c miniRerun/src/init.c miniRerun/src/opcontrol.c miniRerun/src/rerun.c miniRerun/src/sensors.c Files modified:  README.md \n Commit: f8790d394f5f2aada2067e14ba6d26671d1cb935\nDate: Sun Apr 23 06:40:39 2017 +0400\nAuthor: iuyte \nDescription:\nInitial commit\nFiles added:  README.md \n  window.onload = function() { if (window.location.href[0] == \"f\") { var elements = document.querySelectorAll('h1'); for(var i=0; i  "
},
{
	"uri": "https://iuyte.github.io/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "VEX Team 709S\n"
},
{
	"uri": "https://iuyte.github.io/",
	"title": "VEX Robotics Competition Team 709S",
	"tags": [],
	"description": "",
	"content": " Who We Are Team 709S is a team dedicated to three main things:  Build cool, successful, interesting robots Growing knowledge of robotics and STEM fields in the area Encouraging and aiding new teams to grow \nIt currently consists of two brothers, Spencer and Ethan, and was originally based off of BSA Troop 709.\n"
},
{
	"uri": "https://iuyte.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iuyte.github.io/notebook/",
	"title": "Engineering Notebooks",
	"tags": [],
	"description": "",
	"content": "These are the engineering notebooks, one for designing and building, and one for programming.\n\u0026nbsp;Building\u0026nbsp; Programming "
},
{
	"uri": "https://iuyte.github.io/source/",
	"title": "Source",
	"tags": [],
	"description": "A hosting of the robot&#39;s source code",
	"content": "Here you can find the source code for our robot, as well as our github repository\n"
},
{
	"uri": "https://iuyte.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iuyte.github.io/source/include/api.h/",
	"title": "include/API.h",
	"tags": [],
	"description": "Code for include/API.h",
	"content": "/** @file API.h * @brief Provides the high-level user functionality intended for use by typical * VEX Cortex * programmers. * * This file should be included for you in the predefined stubs in each new VEX * Cortex PROS * project through the inclusion of \u0026quot;main.h\u0026quot;. In any new C source file, it is * advisable to * include main.h instead of referencing API.h by name, to better handle any * nomenclature * changes to this file or its contents. * * Copyright (c) 2011-2016, Purdue University ACM SIGBots. * All rights reserved. * * This Source Code Form is subject to the terms of the Mozilla Public * License, v. 2.0. If a copy of the MPL was not distributed with this * file, You can obtain one at http://mozilla.org/MPL/2.0/. * * PROS contains FreeRTOS (http://www.freertos.org) whose source code may be * obtained from http://sourceforge.net/projects/freertos/files/ or on request. */ #ifndef API_H_ #define API_H_ // System includes #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Begin C++ extern to C #ifdef __cplusplus extern \u0026quot;C\u0026quot; { #endif // -------------------- VEX competition functions -------------------- /** DOWN button (valid on channels 5, 6, 7, 8) */ #define JOY_DOWN 1 /** LEFT button (valid on channels 7, 8) */ #define JOY_LEFT 2 /** UP button (valid on channels 5, 6, 7, 8) */ #define JOY_UP 4 /** RIGHT button (valid on channels 7, 8) */ #define JOY_RIGHT 8 /** Analog axis for the X acceleration from the VEX Joystick. */ #define ACCEL_X 5 /** Analog axis for the Y acceleration from the VEX Joystick. */ #define ACCEL_Y 6 /** Returns true if the robot is in autonomous mode, or false otherwise. While * in autonomous mode, joystick inputs will return a neutral value, but serial * port communications (even over VexNET) will still work properly. */ bool isAutonomous(); /** Returns true if the robot is enabled, or false otherwise. While disabled via * the VEX Competition Switch or VEX Field Controller, motors will not function. * However, the digital I/O ports can still be changed, which may indirectly * affect the robot state (e.g. solenoids). Avoid performing externally visible * actions while disabled (the kernel should take care of this most of the * time). */ bool isEnabled(); /** Returns true if a joystick is connected to the specified slot number (1 or * 2), or false otherwise. Useful for automatically merging joysticks for one * operator, or splitting for two. This function does not work properly during * initialize() or initializeIO() and can return false positives. It should be * checked once and stored at the beginning of operatorControl(). */ bool isJoystickConnected(unsigned char joystick); /** Returns true if a VEX field controller or competition switch is connected, * or false otherwise. When in online mode, the switching between autonomous() * and operatorControl() tasks is managed by the PROS kernel.*/ bool isOnline(); /** Gets the value of a control axis on the VEX joystick. Returns the value from * -127 to 127, or 0 if no joystick is connected to the requested slot. * @param joystick the joystick slot to check * @param axis one of 1, 2, 3, 4, ACCEL_X, or ACCEL_Y */ int joystickGetAnalog(unsigned char joystick, unsigned char axis); /** * Gets the value of a button on the VEX joystick. Returns true if that button * is pressed, or * false otherwise. If no joystick is connected to the requested slot, returns * false. * * @param joystick the joystick slot to check * @param buttonGroup one of 5, 6, 7, or 8 to request that button as labelled on * the joystick * @param button one of JOY_UP, JOY_DOWN, JOY_LEFT, or JOY_RIGHT; requesting * JOY_LEFT or * JOY_RIGHT for groups 5 or 6 will cause an undefined value to be returned */ bool joystickGetDigital(unsigned char joystick, unsigned char buttonGroup, unsigned char button); /** * Returns the backup battery voltage in millivolts. * * If no backup battery is connected, returns 0. */ unsigned int powerLevelBackup(); /** * Returns the main battery voltage in millivolts. * * In rare circumstances, this method might return 0. Check the output value for * reasonability * before blindly blasting the user. */ unsigned int powerLevelMain(); /** * Sets the team name displayed to the VEX field control and VEX Firmware * Upgrade. * * @param name a string containing the team name; only the first eight * characters will be shown */ void setTeamName(const char* name); // -------------------- Pin control functions -------------------- /** * There are 8 available analog I/O on the Cortex. */ #define BOARD_NR_ADC_PINS 8 /** * There are 27 available I/O on the Cortex that can be used for digital * communication. * * This excludes the crystal ports but includes the Communications, Speaker, and * Analog ports. * * The motor ports are not on the Cortex and are thus excluded from this count. * Pin 0 is the * Speaker port, pins 1-12 are the standard Digital I/O, 13-20 are the Analog * I/O, 21+22 are * UART1, 23+24 are UART2, and 25+26 are the I2C port. */ #define BOARD_NR_GPIO_PINS 27 /** * Used for digitalWrite() to specify a logic HIGH state to output. * * In reality, using any non-zero expression or \u0026quot;true\u0026quot; will work to set a pin to * HIGH. */ #define HIGH 1 /** * Used for digitalWrite() to specify a logic LOW state to output. * * In reality, using a zero expression or \u0026quot;false\u0026quot; will work to set a pin to LOW. */ #define LOW 0 /** * pinMode() state for digital input, with pullup. * * This is the default state for the 12 Digital pins. The pullup causes the * input to read as * \u0026quot;HIGH\u0026quot; when unplugged, but is fairly weak and can safely be driven by most * sources. Many VEX * digital sensors rely on this behavior and cannot be used with INPUT_FLOATING. */ #define INPUT 0x0A /** * pinMode() state for analog inputs. * * This is the default state for the 8 Analog pins and the Speaker port. This * only works on * pins with analog input capabilities; use anywhere else results in undefined * behavior. */ #define INPUT_ANALOG 0x00 /** * pinMode() state for digital input, without pullup. * * Beware of power consumption, as digital inputs left \u0026quot;floating\u0026quot; may switch * back and forth * and cause spurious interrupts. */ #define INPUT_FLOATING 0x04 /** * pinMode() state for digital output, push-pull. * * This is the mode which should be used to output a digital HIGH or LOW value * from the Cortex. * This mode is useful for pneumatic solenoid valves and VEX LEDs. */ #define OUTPUT 0x01 /** * pinMode() state for open-drain outputs. * * This is useful in a few cases for external electronics and should not be used * for the VEX * solenoid or LEDs. */ #define OUTPUT_OD 0x05 /** * Calibrates the analog sensor on the specified channel. * * This method assumes that the true sensor value is not actively changing at * this time and * computes an average from approximately 500 samples, 1 ms apart, for a 0.5 s * period of * calibration. The average value thus calculated is returned and stored for * later calls to the * analogReadCalibrated() and analogReadCalibratedHR() functions. These * functions will return * the difference between this value and the current sensor value when called. * * Do not use this function in initializeIO(), or when the sensor value might be * unstable * (gyro rotation, accelerometer movement). * * This function may not work properly if the VEX Cortex is tethered to a PC * using the orange * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the * VEX Battery * provides power to sensors. * * @param channel the channel to calibrate from 1-8 * @return the average sensor value computed by this function */ int analogCalibrate(unsigned char channel); /** * Reads an analog input channel and returns the 12-bit value. * * The value returned is undefined if the analog pin has been switched to a * different mode. * This function is Wiring-compatible with the exception of the larger output * range. The * meaning of the returned value varies depending on the sensor attached. * * This function may not work properly if the VEX Cortex is tethered to a PC * using the orange * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the * VEX Battery * provides power to sensors. * * @param channel the channel to read from 1-8 * @return the analog sensor value, where a value of 0 reflects an input voltage * of nearly 0 V * and a value of 4095 reflects an input voltage of nearly 5 V */ int analogRead(unsigned char channel); /** * Reads the calibrated value of an analog input channel. * * The analogCalibrate() function must be run first on that channel. This * function is * inappropriate for sensor values intended for integration, as round-off error * can accumulate * causing drift over time. Use analogReadCalibratedHR() instead. * * This function may not work properly if the VEX Cortex is tethered to a PC * using the orange * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the * VEX Battery * provides power to sensors. * * @param channel the channel to read from 1-8 * @return the difference of the sensor value from its calibrated default from * -4095 to 4095 */ int analogReadCalibrated(unsigned char channel); /** * Reads the calibrated value of an analog input channel 1-8 with enhanced * precision. * * The analogCalibrate() function must be run first. This is intended for * integrated sensor * values such as gyros and accelerometers to reduce drift due to round-off, and * should not be * used on a sensor such as a line tracker or potentiometer. * * The value returned actually has 16 bits of \u0026quot;precision\u0026quot;, even though the ADC * only reads * 12 bits, so that errors induced by the average value being between two values * come out * in the wash when integrated over time. Think of the value as the true value * times 16. * * This function may not work properly if the VEX Cortex is tethered to a PC * using the orange * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the * VEX Battery * provides power to sensors. * * @param channel the channel to read from 1-8 * @return the difference of the sensor value from its calibrated default from * -16384 to 16384 */ int analogReadCalibratedHR(unsigned char channel); /** * Gets the digital value (1 or 0) of a pin configured as a digital input. * * If the pin is configured as some other mode, the digital value which reflects * the current * state of the pin is returned, which may or may not differ from the currently * set value. The * return value is undefined for pins configured as Analog inputs, or for ports * in use by a * Communications interface. This function is Wiring-compatible. * * This function may not work properly if the VEX Cortex is tethered to a PC * using the orange * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the * VEX Battery * provides power to sensors. * * @param pin the pin to read from 1-26 * @return true if the pin is HIGH, or false if it is LOW */ bool digitalRead(unsigned char pin); /** * Sets the digital value (1 or 0) of a pin configured as a digital output. * * If the pin is configured as some other mode, behavior is undefined. This * function is * Wiring-compatible. * * @param pin the pin to write from 1-26 * @param value an expression evaluating to \u0026quot;true\u0026quot; or \u0026quot;false\u0026quot; to set the output * to HIGH or LOW * respectively, or the constants HIGH or LOW themselves */ void digitalWrite(unsigned char pin, bool value); /** * Configures the pin as an input or output with a variety of settings. * * Do note that INPUT by default turns on the pull-up resistor, as most VEX * sensors are * open-drain active low. It should not be a big deal for most push-pull * sources. This function * is Wiring-compatible. * * @param pin the pin to modify from 1-26 * @param mode one of INPUT, INPUT_ANALOG, INPUT_FLOATING, OUTPUT, or OUTPUT_OD */ void pinMode(unsigned char pin, unsigned char mode); /* * Digital port 10 cannot be used as an interrupt port, or for an encoder. Plan * accordingly. */ /** * When used in ioSetInterrupt(), triggers an interrupt on rising edges (LOW to * HIGH). */ #define INTERRUPT_EDGE_RISING 1 /** * When used in ioSetInterrupt(), triggers an interrupt on falling edges (HIGH * to LOW). */ #define INTERRUPT_EDGE_FALLING 2 /** * When used in ioSetInterrupt(), triggers an interrupt on both rising and * falling edges * (LOW to HIGH or HIGH to LOW). */ #define INTERRUPT_EDGE_BOTH 3 /** * Type definition for interrupt handlers. Such functions must accept one * argument indicating * the pin which changed. */ typedef void (*InterruptHandler)(unsigned char pin); /** * Disables interrupts on the specified pin. * * Disabling interrupts on interrupt pins which are not in use conserves * processing time. * * @param pin the pin on which to reset interrupts from 1-9,11-12 */ void ioClearInterrupt(unsigned char pin); /** * Sets up an interrupt to occur on the specified pin, and resets any counters * or timers * associated with the pin. * * Each time the specified change occurs, the function pointer passed in will be * called with * the pin that changed as an argument. Enabling pin-change interrupts consumes * processing * time, so it is best to only enable necessary interrupts and to keep the * InterruptHandler * function short. Pin change interrupts can only be enabled on pins 1-9 and * 11-12. * * Do not use API functions such as delay() inside the handler function, as the * function will * run in an ISR where the scheduler is paused and no other interrupts can * execute. It is best * to quickly update some state and allow a task to perform the work. * * Do not use this function on pins that are also being used by the built-in * ultrasonic or * shaft encoder drivers, or on pins which have been switched to output mode. * * @param pin the pin on which to enable interrupts from 1-9,11-12 * @param edges one of INTERRUPT_EDGE_RISING, INTERRUPT_EDGE_FALLING, or * INTERRUPT_EDGE_BOTH * @param handler the function to call when the condition is satisfied */ void ioSetInterrupt(unsigned char pin, unsigned char edges, InterruptHandler handler); // -------------------- Physical output control functions -------------------- /** * Gets the last set speed of the specified motor channel. * * This speed may have been set by any task or the PROS kernel itself. This is * not guaranteed * to be the speed that the motor is actually running at, or even the speed * currently being * sent to the motor, due to latency in the Motor Controller 29 protocol and * physical loading. * To measure actual motor shaft revolution speed, attach a VEX Integrated Motor * Encoder or * VEX Quadrature Encoder and use the velocity functions associated with each. * * @param channel the motor channel to fetch from 1-10 * @return the speed last sent to this channel; -127 is full reverse and 127 is * full forward, * with 0 being off */ int motorGet(unsigned char channel); /** * Sets the speed of the specified motor channel. * * Do not use motorSet() with the same channel argument from two different * tasks. It is safe to * use motorSet() with different channel arguments from different tasks. * * @param channel the motor channel to modify from 1-10 * @param speed the new signed speed; -127 is full reverse and 127 is full * forward, with 0 * being off */ void motorSet(unsigned char channel, int speed); /** * Stops the motor on the specified channel, equivalent to calling motorSet() * with an argument * of zero. * * This performs a coasting stop, not an active brake. Since motorStop is * similar to * motorSet(0), see the note for motorSet() about use from multiple tasks. * * @param channel the motor channel to stop from 1-10 */ void motorStop(unsigned char channel); /** * Stops all motors; significantly faster than looping through all motor ports * and calling * motorSet(channel, 0) on each one. */ void motorStopAll(); /** * Initializes VEX speaker support. * * The VEX speaker is not thread safe; it can only be used from one task at a * time. Using the * VEX speaker may impact robot performance. Teams may benefit from an if * statement that only * enables sound if isOnline() returns false. */ void speakerInit(); /** * Plays up to three RTTTL (Ring Tone Text Transfer Language) songs * simultaneously over the * VEX speaker. The audio is mixed to allow polyphonic sound to be played. Many * simple songs * are available in RTTTL format online, or compose your own. * * The song must not be NULL, but unused tracks within the song can be set to * NULL. If any of * the three song tracks is invalid, the result of this function is undefined. * * The VEX speaker is not thread safe; it can only be used from one task at a * time. Using the * VEX speaker may impact robot performance. Teams may benefit from an if * statement that only * enables sound if isOnline() returns false. * * @param songs an array of up to three (3) RTTTL songs as string values to play */ void speakerPlayArray(const char** songs); /** * Plays an RTTTL (Ring Tone Text Transfer Language) song over the VEX speaker. * Many simple * songs are available in RTTTL format online, or compose your own. * * The song must not be NULL. If an invalid song is specified, the result of * this function is * undefined. * * The VEX speaker is not thread safe; it can only be used from one task at a * time. Using the * VEX speaker may impact robot performance. Teams may benefit from an if * statement that only * enables sound if isOnline() returns false. * * @param song the RTTTL song as a string value to play */ void speakerPlayRtttl(const char* song); /** * Powers down and disables the VEX speaker. * * If a song is currently being played in another task, the behavior of this * function is * undefined, since the VEX speaker is not thread safe. */ void speakerShutdown(); // -------------------- VEX sensor control functions -------------------- /** * IME addresses end at 0x1F. Actually using more than 10 (address 0x1A) * encoders will cause * unreliable communications. */ #define IME_ADDR_MAX 0x1F /** * Initializes all IMEs. * * IMEs are assigned sequential incrementing addresses, beginning with the first * IME on the * chain (closest to the VEX Cortex I2C port). Therefore, a given configuration * of IMEs will * always have the same ID assigned to each encoder. The addresses range from 0 * to * IME_ADDR_MAX, so the first encoder gets 0, the second gets 1, ... * * This function should most likely be used in initialize(). Do not use it in * initializeIO() or * at any other time when the scheduler is paused (like an interrupt). Checking * the return * value of this function is important to ensure that all IMEs are plugged in * and responding as * expected. * * This function, unlike the other IME functions, is not thread safe. If using * imeInitializeAll * to re-initialize encoders, calls to other IME functions might behave * unpredictably during * this function's execution. * * @return the number of IMEs successfully initialized. */ unsigned int imeInitializeAll(); /** * Gets the current 32-bit count of the specified IME. * * Much like the count for a quadrature encoder, the tick count is signed and * cumulative. * The value reflects total counts since the last reset. Different VEX Motor * Encoders have a * different number of counts per revolution: * * * \\c 240.448 for the 269 IME * * \\c 627.2 for the 393 IME in high torque mode (factory default) * * \\c 392 for the 393 IME in high speed mode * * If the IME address is invalid, or the IME has not been reset or initialized, * the value * stored in *value is undefined. * * @param address the IME address to fetch from 0 to IME_ADDR_MAX * @param value a pointer to the location where the value will be stored * (obtained using the * \u0026quot;\u0026amp;\u0026quot; operator on the target variable name e.g. \u0026lt;code\u0026gt;imeGet(2, * \u0026amp;counts)\u0026lt;/code\u0026gt;) * @return true if the count was successfully read and the value stored in * *value is valid; * false otherwise */ bool imeGet(unsigned char address, int* value); /** * Gets the current rotational velocity of the specified IME. * * In this version of PROS, the velocity is positive if the IME count is * increasing and * negative if the IME count is decreasing. The velocity is in RPM of the * internal encoder * wheel. Since checking the IME for its type cannot reveal whether the motor * gearing is * high speed or high torque (in the 2-Wire Motor 393 case), the user must * divide the return * value by the number of output revolutions per encoder revolution: * * * \\c 30.056 for the 269 IME * * \\c 39.2 for the 393 IME in high torque mode (factory default) * * \\c 24.5 for the 393 IME in high speed mode * * If the IME address is invalid, or the IME has not been reset or initialized, * the value * stored in *value is undefined. * * @param address the IME address to fetch from 0 to IME_ADDR_MAX * @param value a pointer to the location where the value will be stored * (obtained using the * \u0026quot;\u0026amp;\u0026quot; operator on the target variable name e.g. \u0026lt;code\u0026gt;imeGetVelocity(2, * \u0026amp;counts)\u0026lt;/code\u0026gt;) * @return true if the velocity was successfully read and the value stored in * *value is valid; * false otherwise */ bool imeGetVelocity(unsigned char address, int* value); /** * Resets the specified IME's counters to zero. * * This method can be used while the IME is rotating. * * @param address the IME address to reset from 0 to IME_ADDR_MAX * @return true if the reset succeeded; false otherwise */ bool imeReset(unsigned char address); /** * Shuts down all IMEs on the chain; their addresses return to the default and * the stored * counts and velocities are lost. This function, unlike the other IME * functions, is not * thread safe. * * To use the IME chain again, wait at least 0.25 seconds before using * imeInitializeAll again. */ void imeShutdown(); /** * Reference type for an initialized gyro. * * Gyro information is stored as an opaque pointer to a structure in memory; as * this is a * pointer type, it can be safely passed or stored by value. */ typedef void* Gyro; /** * Gets the current gyro angle in degrees, rounded to the nearest degree. * * There are 360 degrees in a circle. * * @param gyro the Gyro object from gyroInit() to read * @return the signed and cumulative number of degrees rotated around the gyro's * vertical axis * since the last start or reset */ int gyroGet(Gyro gyro); /** * Initializes and enables a gyro on an analog port. * * NULL will be returned if the port is invalid or the gyro is already in use. * Initializing a * gyro implicitly calibrates it and resets its count. Do not move the robot * while the gyro is * being calibrated. It is suggested to call this function in initialize() and * to place the * robot in its final position before powering it on. * * The multiplier parameter can tune the gyro to adapt to specific sensors. The * default value * at this time is 196; higher values will increase the number of degrees * reported for a fixed * actual rotation, while lower values will decrease the number of degrees * reported. If your * robot is consistently turning too far, increase the multiplier, and if it is * not turning * far enough, decrease the multiplier. * * @param port the analog port to use from 1-8 * @param multiplier an optional constant to tune the gyro readings; use 0 for * the default * value * @return a Gyro object to be stored and used for later calls to gyro functions */ Gyro gyroInit(unsigned char port, unsigned short multiplier); /** * Resets the gyro to zero. * * It is safe to use this method while a gyro is enabled. It is not necessary to * call this * method before stopping or starting a gyro. * * @param gyro the Gyro object from gyroInit() to reset */ void gyroReset(Gyro gyro); /** * Stops and disables the gyro. * * Gyros use processing power, so disabling unused gyros increases code * performance. * The gyro's position will be retained. * * @param gyro the Gyro object from gyroInit() to stop */ void gyroShutdown(Gyro gyro); /** * Reference type for an initialized encoder. * * Encoder information is stored as an opaque pointer to a structure in memory; * as this is a * pointer type, it can be safely passed or stored by value. */ typedef void* Encoder; /** * Gets the number of ticks recorded by the encoder. * * There are 360 ticks in one revolution. * * @param enc the Encoder object from encoderInit() to read * @return the signed and cumulative number of counts since the last start or * reset */ int encoderGet(Encoder enc); /** * Initializes and enables a quadrature encoder on two digital ports. * * Neither the top port nor the bottom port can be digital port 10. NULL will be * returned if * either port is invalid or the encoder is already in use. Initializing an * encoder implicitly * resets its count. * * @param portTop the \u0026quot;top\u0026quot; wire from the encoder sensor with the removable * cover side UP * @param portBottom the \u0026quot;bottom\u0026quot; wire from the encoder sensor * @param reverse if \u0026quot;true\u0026quot;, the sensor will count in the opposite direction * @return an Encoder object to be stored and used for later calls to encoder * functions */ Encoder encoderInit(unsigned char portTop, unsigned char portBottom, bool reverse); /** * Resets the encoder to zero. * * It is safe to use this method while an encoder is enabled. It is not * necessary to call this * method before stopping or starting an encoder. * * @param enc the Encoder object from encoderInit() to reset */ void encoderReset(Encoder enc); /** * Stops and disables the encoder. * * Encoders use processing power, so disabling unused encoders increases code * performance. * The encoder's count will be retained. * * @param enc the Encoder object from encoderInit() to stop */ void encoderShutdown(Encoder enc); /** * Reference type for an initialized ultrasonic sensor. * * Ultrasonic information is stored as an opaque pointer to a structure in * memory; as this is a * pointer type, it can be safely passed or stored by value. */ typedef void* Ultrasonic; /** * Gets the current ultrasonic sensor value in centimeters. * * If no object was found, zero is returned. If the ultrasonic sensor was never * started, the * return value is undefined. Round and fluffy objects can cause inaccurate * values to be * returned. * * @param ult the Ultrasonic object from ultrasonicInit() to read * @return the distance to the nearest object in centimeters */ int ultrasonicGet(Ultrasonic ult); /** * Initializes an ultrasonic sensor on the specified digital ports. * * The ultrasonic sensor will be polled in the background in concert with the * other sensors * registered using this method. NULL will be returned if either port is invalid * or the * ultrasonic sensor port is already in use. * * @param portEcho the port connected to the orange cable from 1-9,11-12 * @param portPing the port connected to the yellow cable from 1-12 * @return an Ultrasonic object to be stored and used for later calls to * ultrasonic functions */ Ultrasonic ultrasonicInit(unsigned char portEcho, unsigned char portPing); /** * Stops and disables the ultrasonic sensor. * * The last distance it had before stopping will be retained. One more ping * operation may occur * before the sensor is fully disabled. * * @param ult the Ultrasonic object from ultrasonicInit() to stop */ void ultrasonicShutdown(Ultrasonic ult); // -------------------- Custom sensor control functions -------------------- // ---- I2C port control ---- /** * i2cRead - Reads the specified number of data bytes from the specified 7-bit * I2C address. The * bytes will be stored at the specified location. Returns true if successful or * false if * failed. If only some bytes could be read, false is still returned. * * The I2C address should be right-aligned; the R/W bit is automatically * supplied. * * Since most I2C devices use an 8-bit register architecture, this method has * limited * usefulness. Consider i2cReadRegister instead for the vast majority of * applications. */ bool i2cRead(uint8_t addr, uint8_t* data, uint16_t count); /** * i2cReadRegister - Reads the specified amount of data from the given register * address on * the specified 7-bit I2C address. Returns true if successful or false if * failed. If only some * bytes could be read, false is still returned. * * The I2C address should be right-aligned; the R/W bit is automatically * supplied. * * Most I2C devices support an auto-increment address feature, so using this * method to read * more than one byte will usually read a block of sequential registers. Try to * merge reads to * separate registers into a larger read using this function whenever possible * to improve code * reliability, even if a few intermediate values need to be thrown away. */ bool i2cReadRegister(uint8_t addr, uint8_t reg, uint8_t* value, uint16_t count); /** * i2cWrite - Writes the specified number of data bytes to the specified 7-bit * I2C address. * Returns true if successful or false if failed. If only smoe bytes could be * written, false * is still returned. * * The I2C address should be right-aligned; the R/W bit is automatically * supplied. * * Since most I2C devices use an 8-bit register architecture, this method is * mostly useful for * setting the register position (most devices remember the last-used address) * or writing a * sequence of bytes to one register address using an auto-increment feature. In * these cases, * the first byte written from the data buffer should have the register address * to use. */ bool i2cWrite(uint8_t addr, uint8_t* data, uint16_t count); /** * i2cWriteRegister - Writes the specified data byte to a register address on * the specified * 7-bit I2C address. Returns true if successful or false if failed. * * The I2C address should be right-aligned; the R/W bit is automatically * supplied. * * Only one byte can be written to each register address using this method. * While useful for * the vast majority of I2C operations, writing multiple bytes requires the * i2cWrite method. */ bool i2cWriteRegister(uint8_t addr, uint8_t reg, uint16_t value); /** * FILE is an integer referring to a stream for the standard I/O functions. * * PROS_FILE * is the standard library method of referring to a file pointer, * even though there is * actually nothing there. */ typedef int PROS_FILE; /** * Bit mask for usartInit() for 8 data bits (typical) */ #define SERIAL_DATABITS_8 0x0000 /** * Bit mask for usartInit() for 9 data bits */ #define SERIAL_DATABITS_9 0x1000 /** * Bit mask for usartInit() for 1 stop bit (typical) */ #define SERIAL_STOPBITS_1 0x0000 /** * Bit mask for usartInit() for 2 stop bits */ #define SERIAL_STOPBITS_2 0x2000 /** * Bit mask for usartInit() for No parity (typical) */ #define SERIAL_PARITY_NONE 0x0000 /** * Bit mask for usartInit() for Even parity */ #define SERIAL_PARITY_EVEN 0x0400 /** * Bit mask for usartInit() for Odd parity */ #define SERIAL_PARITY_ODD 0x0600 /** * Specifies the default serial settings when used in usartInit() */ #define SERIAL_8N1 0x0000 /** * Initialize the specified serial interface with the given connection * parameters. * * I/O to the port is accomplished using the \u0026quot;standard\u0026quot; I/O functions such as * fputs(), * fprintf(), and fputc(). * * Re-initializing an open port may cause loss of data in the buffers. This * routine may be * safely called from initializeIO() or when the scheduler is paused. If I/O is * attempted on a * serial port which has never been opened, the behavior will be the same as if * the port had * been disabled. * * @param usart the port to open, either \u0026quot;uart1\u0026quot; or \u0026quot;uart2\u0026quot; * @param baud the baud rate to use from 2400 to 1000000 baud * @param flags a bit mask combination of the SERIAL_* flags specifying parity, * stop, and data * bits */ void usartInit(PROS_FILE* usart, unsigned int baud, unsigned int flags); /** * Disables the specified USART interface. * * Any data in the transmit and receive buffers will be lost. Attempts to read * from the port * when it is disabled will deadlock, and attempts to write to it may deadlock * depending on * the state of the buffer. * * @param usart the port to close, either \u0026quot;uart1\u0026quot; or \u0026quot;uart2\u0026quot; */ void usartShutdown(PROS_FILE* usart); // -------------------- Character input and output -------------------- /** * The standard output stream uses the PC debug terminal. */ #define stdout ((PROS_FILE*)3) /** * The standard input stream uses the PC debug terminal. */ #define stdin ((PROS_FILE*)3) /** * UART 1 on the Cortex; must be opened first using usartInit(). */ #define uart1 ((PROS_FILE*)1) /** * UART 2 on the Cortex; must be opened first using usartInit(). */ #define uart2 ((PROS_FILE*)2) #ifndef EOF /** * EOF is a value evaluating to -1. */ #define EOF ((int)-1) #endif #ifndef SEEK_SET /** * SEEK_SET is used in fseek() to denote an absolute position in bytes from the * start of the * file. */ #define SEEK_SET 0 #endif #ifndef SEEK_CUR /** * SEEK_CUR is used in fseek() to denote an relative position in bytes from the * current file * location. */ #define SEEK_CUR 1 #endif #ifndef SEEK_END /** * SEEK_END is used in fseek() to denote an absolute position in bytes from the * end of the * file. The offset will most likely be negative in this case. */ #define SEEK_END 2 #endif /** * Closes the specified file descriptor. This function does not work on * communication ports; * use usartShutdown() instead. * * @param stream the file descriptor to close from fopen() */ void fclose(PROS_FILE* stream); /** * Returns the number of characters that can be read without blocking (the * number of * characters available) from the specified stream. This only works for * communication ports and * files in Read mode; for files in Write mode, 0 is always returned. * * This function may underestimate, but will not overestimate, the number of * characters which * meet this criterion. * * @param stream the stream to read (stdin, uart1, uart2, or an open file in * Read mode) * @return the number of characters which meet this criterion; if this number * cannot be * determined, returns 0 */ int fcount(PROS_FILE* stream); /** * Delete the specified file if it exists and is not currently open. * * The file will actually be erased from memory on the next re-boot. A physical * power cycle is * required to purge deleted files and free their allocated space for new files * to be written. * Deleted files are still considered inaccessible to fopen() in Read mode. * * @param file the file name to erase * @return 0 if the file was deleted, or 1 if the file could not be found */ int fdelete(const char* file); /** * Checks to see if the specified stream is at its end. This only works for * communication ports * and files in Read mode; for files in Write mode, 1 is always returned. * * @param stream the channel to check (stdin, uart1, uart2, or an open file in * Read mode) * @return 0 if the stream is not at EOF, or 1 otherwise. */ int feof(PROS_FILE* stream); /** * Flushes the data on the specified file channel open in Write mode. This * function has no * effect on a communication port or a file in Read mode, as these streams are * always flushed as * quickly as possible by the kernel. * * Successful completion of an fflush function on a file in Write mode cannot * guarantee that * the file is vaild until fclose() is used on that file descriptor. * * @param stream the channel to flush (an open file in Write mode) * @return 0 if the data was successfully flushed, EOF otherwise */ int fflush(PROS_FILE* stream); /** * Reads and returns one character from the specified stream, blocking until * complete. * * Do not use fgetc() on a VEX LCD port; deadlock may occur. * * @param stream the stream to read (stdin, uart1, uart2, or an open file in * Read mode) * @return the next character from 0 to 255, or -1 if no character can be read */ int fgetc(PROS_FILE* stream); /** * Reads a string from the specified stream, storing the characters into the * memory at str. * Characters will be read until the specified limit is reached, a new line is * found, or the * end of file is reached. * * If the stream is already at end of file (for files in Read mode), NULL will * be returned; * otherwise, at least one character will be read and stored into str. * * @param str the location where the characters read will be stored * @param num the maximum number of characters to store; at most (num - 1) * characters will be * read, with a null terminator ('\\0') automatically appended * @param stream the channel to read (stdin, uart1, uart2, or an open file in * Read mode) * @return str, or NULL if zero characters could be read */ char* fgets(char* str, int num, PROS_FILE* stream); /** * Opens the given file in the specified mode. The file name is truncated to * eight characters. * Only four files can be in use simultaneously in any given time, with at most * one of those * files in Write mode. This function does not work on communication ports; use * usartInit() * instead. * * mode can be \u0026quot;r\u0026quot; or \u0026quot;w\u0026quot;. Due to the nature of the VEX Cortex memory, the \u0026quot;r+\u0026quot;, * \u0026quot;w+\u0026quot;, and \u0026quot;a\u0026quot; * modes are not supported by the file system. * * Opening a file that does not exist in Read mode will fail and return NULL, * but opening a new * file in Write mode will create it if there is space. Opening a file that * already exists in * Write mode will destroy the contents and create a new blank file if space is * available. * * There are important considerations when using of the file system on the VEX * Cortex. Reading * from files is safe, but writing to files should only be performed when robot * actuators have * been stopped. PROS will attempt to continue to handle events during file * writes, but most * user tasks cannot execute during file writing. Powering down the VEX Cortex * mid-write may * cause file system corruption. * * @param file the file name * @param mode the file mode * @return a file descriptor pointing to the new file, or NULL if the file could * not be opened */ PROS_FILE* fopen(const char* file, const char* mode); /** * Prints the simple string to the specified stream. * * This method is much, much faster than fprintf() and does not add a new line * like fputs(). * Do not use fprint() on a VEX LCD port. Use lcdSetText() instead. * * @param string the string to write * @param stream the stream to write (stdout, uart1, uart2, or an open file in * Write mode) */ void fprint(const char* string, PROS_FILE* stream); /** * Writes one character to the specified stream. * * Do not use fputc() on a VEX LCD port. Use lcdSetText() instead. * * @param value the character to write (a value of type \u0026quot;char\u0026quot; can be used) * @param stream the stream to write (stdout, uart1, uart2, or an open file in * Write mode) * @return the character written */ int fputc(int value, PROS_FILE* stream); /** * Behaves the same as the \u0026quot;fprint\u0026quot; function, and appends a trailing newline * (\u0026quot;\\n\u0026quot;). * * Do not use fputs() on a VEX LCD port. Use lcdSetText() instead. * * @param string the string to write * @param stream the stream to write (stdout, uart1, uart2, or an open file in * Write mode) * @return the number of characters written, excluding the new line */ int fputs(const char* string, PROS_FILE* stream); /** * Reads data from a stream into memory. Returns the number of bytes thus read. * * If the memory at ptr cannot store (size * count) bytes, undefined behavior * occurs. * * @param ptr a pointer to where the data will be stored * @param size the size of each data element to read in bytes * @param count the number of data elements to read * @param stream the stream to read (stdout, uart1, uart2, or an open file in * Read mode) * @return the number of bytes successfully read */ size_t fread(void* ptr, size_t size, size_t count, PROS_FILE* stream); /** * Seeks within a file open in Read mode. This function will fail when used on a * file in Write * mode or on any communications port. * * @param stream the stream to seek within * @param offset the location within the stream to seek * @param origin the reference location for offset: SEEK_CUR, SEEK_SET, or * SEEK_END * @return 0 if the seek was successful, or 1 otherwise */ int fseek(PROS_FILE* stream, long int offset, int origin); /** * Returns the current position of the stream. This function works on files in * either Read or * Write mode, but will fail on communications ports. * * @param stream the stream to check * @return the offset of the stream, or -1 if the offset could not be determined */ long int ftell(PROS_FILE* stream); /** * Writes data from memory to a stream. Returns the number of bytes thus * written. * * If the memory at ptr is not as long as (size * count) bytes, undefined * behavior occurs. * * @param ptr a pointer to the data to write * @param size the size of each data element to write in bytes * @param count the number of data elements to write * @param stream the stream to write (stdout, uart1, uart2, or an open file in * Write mode) * @return the number of bytes successfully written */ size_t fwrite(const void* ptr, size_t size, size_t count, PROS_FILE* stream); /** * Reads and returns one character from \u0026quot;stdin\u0026quot;, which is the PC debug terminal. * * @return the next character from 0 to 255, or -1 if no character can be read */ int getchar(); /** * Prints the simple string to the debug terminal without formatting. * * This method is much, much faster than printf(). * * @param string the string to write */ void print(const char* string); /** * Writes one character to \u0026quot;stdout\u0026quot;, which is the PC debug terminal, and returns * the input * value. * * When using a wireless connection, one may need to press the spacebar before * the input is * visible on the terminal. * * @param value the character to write (a value of type \u0026quot;char\u0026quot; can be used) * @return the character written */ int putchar(int value); /** * Behaves the same as the \u0026quot;print\u0026quot; function, and appends a trailing newline * (\u0026quot;\\n\u0026quot;). * * @param string the string to write * @return the number of characters written, excluding the new line */ int puts(const char* string); /** * Prints the formatted string to the specified output stream. * * The specifiers supported by this minimalistic printf() function are: * * @c \\%d: Signed integer in base 10 (int) * * @c \\%u: Unsigned integer in base 10 (unsigned int) * * @c \\%x, @c \\%X: Integer in base 16 (unsigned int, int) * * @c \\%p: Pointer (void *, int *, ...) * * @c \\%c: Character (char) * * @c \\%s: Null-terminated string (char *) * * @c \\%%: Single literal percent sign * * @c \\%f: Floating-point number * * Specifiers can be modified with: * * @c 0: Zero-pad, instead of space-pad * * @c a.b: Make the field at least \u0026quot;a\u0026quot; characters wide. If \u0026quot;b\u0026quot; is specified * for \u0026quot;%f\u0026quot;, changes the * number of digits after the decimal point * * @c -: Left-align, instead of right-align * * @c +: Always display the sign character (displays a leading \u0026quot;+\u0026quot; for * positive numbers) * * @c l: Ignored for compatibility * * Invalid format specifiers, or mismatched parameters to specifiers, cause * undefined behavior. * Other characters are written out verbatim. Do not use fprintf() on a VEX LCD * port. * Use lcdPrint() instead. * * @param stream the stream to write (stdout, uart1, or uart2) * @param formatString the format string as specified above * @return the number of characters written */ int fprintf(PROS_FILE* stream, const char* formatString, ...); /** * Prints the formatted string to the debug stream (the PC terminal). * * @param formatString the format string as specified in fprintf() * @return the number of characters written */ int printf(const char* formatString, ...); /** * Prints the formatted string to the string buffer with the specified length * limit. * * The length limit, as per the C standard, includes the trailing null * character, so an * argument of 256 will cause a maximum of 255 non-null characters to be * printed, and one null * terminator in all cases. * * @param buffer the string buffer where characters can be placed * @param limit the maximum number of characters to write * @param formatString the format string as specified in fprintf() * @return the number of characters stored */ int snprintf(char* buffer, size_t limit, const char* formatString, ...); /** * Prints the formatted string to the string buffer. * * If the buffer is not big enough to contain the complete formatted output, * undefined behavior * occurs. See snprintf() for a safer version of this function. * * @param buffer the string buffer where characters can be placed * @param formatString the format string as specified in fprintf() * @return the number of characters stored */ int sprintf(char* buffer, const char* formatString, ...); /** * LEFT button on LCD for use with lcdReadButtons() */ #define LCD_BTN_LEFT 1 /** * CENTER button on LCD for use with lcdReadButtons() */ #define LCD_BTN_CENTER 2 /** * RIGHT button on LCD for use with lcdReadButtons() */ #define LCD_BTN_RIGHT 4 /** * Clears the LCD screen on the specified port. * * Printing to a line implicitly overwrites the contents, so clearing should * only be required * at startup. * * @param lcdPort the LCD to clear, either uart1 or uart2 */ void lcdClear(PROS_FILE* lcdPort); /** * Initializes the LCD port, but does not change the text or settings. * * If the LCD was not initialized before, the text currently on the screen will * be undefined. * The port will not be usable with standard serial port functions until the LCD * is stopped. * * @param lcdPort the LCD to initialize, either uart1 or uart2 */ void lcdInit(PROS_FILE* lcdPort); /** * Prints the formatted string to the attached LCD. * * The output string will be truncated as necessary to fit on the LCD screen, 16 * characters * wide. It is probably better to generate the string in a local buffer and use * lcdSetText() * but this method is provided for convenience. * * @param lcdPort the LCD to write, either uart1 or uart2 * @param line the LCD line to write, either 1 or 2 * @param formatString the format string as specified in fprintf() */ #ifdef DOXYGEN void lcdPrint(PROS_FILE* lcdPort, unsigned char line, const char* formatString, ...); #else void __attribute__((format(printf, 3, 4))) lcdPrint(PROS_FILE* lcdPort, unsigned char line, const char* formatString, ...); #endif /** * Reads the user button status from the LCD display. * * For example, if the left and right buttons are pushed, (1 | 4) = 5 will be * returned. 0 is * returned if no buttons are pushed. * * @param lcdPort the LCD to poll, either uart1 or uart2 * @return the buttons pressed as a bit mask */ unsigned int lcdReadButtons(PROS_FILE* lcdPort); /** * Sets the specified LCD backlight to be on or off. * * Turning it off will save power but may make it more difficult to read in dim * conditions. * * @param lcdPort the LCD to adjust, either uart1 or uart2 * @param backlight true to turn the backlight on, or false to turn it off */ void lcdSetBacklight(PROS_FILE* lcdPort, bool backlight); /** * Prints the string buffer to the attached LCD. * * The output string will be truncated as necessary to fit on the LCD screen, 16 * characters * wide. This function, like fprint(), is much, much faster than a formatted * routine such as * lcdPrint() and consumes less memory. * * @param lcdPort the LCD to write, either uart1 or uart2 * @param line the LCD line to write, either 1 or 2 * @param buffer the string to write */ void lcdSetText(PROS_FILE* lcdPort, unsigned char line, const char* buffer); /** * Shut down the specified LCD port. * * @param lcdPort the LCD to stop, either uart1 or uart2 */ void lcdShutdown(PROS_FILE* lcdPort); // -------------------- Real-time scheduler functions -------------------- /** * Only this many tasks can exist at once. Attempts to create further tasks will * not succeed * until tasks end or are destroyed, AND the idle task cleans them up. * * Changing this value will not change the limit without a kernel recompile. The * idle task * and VEX daemon task count against the limit. The user autonomous() or * teleop() also counts * against the limit, so 12 tasks usually remain for other uses. */ #define TASK_MAX 16 /** * The maximum number of available task priorities, which run from 0 to 5. * * Changing this value will not change the priority count without a kernel * recompile. */ #define TASK_MAX_PRIORITIES 6 /** * The lowest priority that can be assigned to a task, which puts it on a level * with the idle * task. This may cause severe performance problems and is generally not * recommended. */ #define TASK_PRIORITY_LOWEST 0 /** * The default task priority, which should be used for most tasks. * * Default tasks such as autonomous() inherit this priority. */ #define TASK_PRIORITY_DEFAULT 2 /** * The highest priority that can be assigned to a task. Unlike the lowest * priority, this * priority can be safely used without hampering interrupts. Beware of deadlock. */ #define TASK_PRIORITY_HIGHEST (TASK_MAX_PRIORITIES - 1) /** * The recommended stack size for a new task that does an average amount of * work. This stack * size is used for default tasks such as autonomous(). * * This is probably OK for 4-5 levels of function calls and the use of printf() * with several * arguments. Tasks requiring deep recursion or large local buffers will need a * bigger stack. */ #define TASK_DEFAULT_STACK_SIZE 512 /** * The minimum stack depth for a task. Scheduler state is stored on the stack, * so even if the * task never uses the stack, at least this much space must be allocated. * * Function calls and other seemingly innocent constructs may place information * on the stack. * Err on the side of a larger stack when possible. */ #define TASK_MINIMAL_STACK_SIZE 64 /** * Constant returned from taskGetState() when the task is dead or nonexistant. */ #define TASK_DEAD 0 /** * Constant returned from taskGetState() when the task is actively executing. */ #define TASK_RUNNING 1 /** * Constant returned from taskGetState() when the task is exists and is * available to run, but * not currently running. */ #define TASK_RUNNABLE 2 /** * Constant returned from taskGetState() when the task is delayed or blocked * waiting for a * semaphore, mutex, or I/O operation. */ #define TASK_SLEEPING 3 /** * Constant returned from taskGetState() when the task is suspended using * taskSuspend(). */ #define TASK_SUSPENDED 4 /** * Type by which tasks are referenced. * * As this is a pointer type, it can be safely passed or stored by value. */ typedef void* TaskHandle; /** * Type by which mutexes are referenced. * * As this is a pointer type, it can be safely passed or stored by value. */ typedef void* Mutex; /** * Type by which semaphores are referenced. * * As this is a pointer type, it can be safely passed or stored by value. */ typedef void* Semaphore; /** * Type for defining task functions. Task functions must accept one parameter of * type * \u0026quot;void *\u0026quot;; they need not use it. * * For example: * * void MyTask(void *ignore) { * while (1); * } */ typedef void (*TaskCode)(void*); /** * Creates a new task and add it to the list of tasks that are ready to run. * * @param taskCode the function to execute in its own task * @param stackDepth the number of variables available on the stack (4 * * stackDepth bytes will * be allocated on the Cortex) * @param parameters an argument passed to the taskCode function * @param priority a value from TASK_PRIORITY_LOWEST to TASK_PRIORITY_HIGHEST * determining the * initial priority of the task * @return a handle to the created task, or NULL if an error occurred */ TaskHandle taskCreate(TaskCode taskCode, const unsigned int stackDepth, void* parameters, const unsigned int priority); /** * Delays the current task for a given number of milliseconds. * * Delaying for a period of zero will force a reschedule, where tasks of equal * priority may be * scheduled if available. The calling task will still be available for * immediate rescheduling * once the other tasks have had their turn or if nothing of equal or higher * priority is * available to be scheduled. * * This is not the best method to have a task execute code at predefined * intervals, as the * delay time is measured from when the delay is requested. To delay cyclically, * use * taskDelayUntil(). * * @param msToDelay the number of milliseconds to wait, with 1000 milliseconds * per second */ void taskDelay(const unsigned long msToDelay); /** * Delays the current task until a specified time. The task will be unblocked * at the time *previousWakeTime + cycleTime, and *previousWakeTime will be * changed to reflect * the time at which the task will unblock. * * If the target time is in the past, no delay occurs, but a reschedule is * forced, as if * taskDelay() was called with an argument of zero. If the sum of cycleTime and * *previousWakeTime overflows or underflows, undefined behavior occurs. * * This function should be used by cyclical tasks to ensure a constant execution * frequency. * While taskDelay() specifies a wake time relative to the time at which the * function is * called, taskDelayUntil() specifies the absolute future time at which it * wishes to unblock. * Calling taskDelayUntil with the same cycleTime parameter value in a loop, * with * previousWakeTime referring to a local variable initialized to millis(), will * cause the * loop to execute with a fixed period. * * @param previousWakeTime a pointer to the location storing the last unblock * time, obtained * by using the \u0026quot;\u0026amp;\u0026quot; operator on a variable (e.g. \u0026quot;taskDelayUntil(\u0026amp;now, 50);\u0026quot;) * @param cycleTime the number of milliseconds to wait, with 1000 milliseconds * per second */ void taskDelayUntil(unsigned long* previousWakeTime, const unsigned long cycleTime); /** * Kills and removes the specified task from the kernel task list. * * Deleting the last task will end the program, possibly leading to undesirable * states as * some outputs may remain in their last set configuration. * * NOTE: The idle task is responsible for freeing the kernel allocated memory * from tasks that * have been deleted. It is therefore important that the idle task is not * starved of * processing time. Memory allocated by the task code is not automatically * freed, and should be * freed before the task is deleted. * * @param taskToDelete the task to kill; passing NULL kills the current task */ void taskDelete(TaskHandle taskToDelete); /** * Determines the number of tasks that are currently being managed. * * This includes all ready, blocked and suspended tasks. A task that has been * deleted but not * yet freed by the idle task will also be included in the count. Tasks recently * created may * take one context switch to be counted. * * @return the number of tasks that are currently running, waiting, or suspended */ unsigned int taskGetCount(); /** * Retrieves the state of the specified task. Note that the state of tasks which * have died may * be re-used for future tasks, causing the value returned by this function to * reflect a * different task than possibly intended in this case. * * @param task Handle to the task to query. Passing NULL will query the current * task status * (which will, by definition, be TASK_RUNNING if this call returns) * * @return A value reflecting the task's status, one of the constants TASK_DEAD, * TASK_RUNNING, * TASK_RUNNABLE, TASK_SLEEPING, or TASK_SUSPENDED */ unsigned int taskGetState(TaskHandle task); /** * Obtains the priority of the specified task. * * @param task the task to check; passing NULL checks the current task * @return the priority of that task from 0 to TASK_MAX_PRIORITIES */ unsigned int taskPriorityGet(const TaskHandle task); /** * Sets the priority of the specified task. * * A context switch may occur before the function returns if the priority being * set is higher * than the currently executing task and the task being mutated is available to * be scheduled. * * @param task the task to change; passing NULL changes the current task * @param newPriority a value between TASK_PRIORITY_LOWEST and * TASK_PRIORITY_HIGHEST inclusive * indicating the new task priority */ void taskPrioritySet(TaskHandle task, const unsigned int newPriority); /** * Resumes the specified task. * * A task that has been suspended by one or more calls to taskSuspend() will be * made available * for scheduling again by a call to taskResume(). If the task was not suspended * at the time * of the call to taskResume(), undefined behavior occurs. * * @param taskToResume the task to change; passing NULL is not allowed as the * current task * cannot be suspended (it is obviously running if this function is called) */ void taskResume(TaskHandle taskToResume); /** * Starts a task which will periodically call the specified function. * * Intended for use as a quick-start skeleton for cyclic tasks with higher * priority than the * \u0026quot;main\u0026quot; tasks. The created task will have priority TASK_PRIORITY_DEFAULT + 1 * with the default * stack size. To customize behavior, create a task manually with the specified * function. * * This task will automatically terminate after one further function invocation * when the robot * is disabled or when the robot mode is switched. * * @param fn the function to call in this loop * @param increment the delay between successive calls in milliseconds; the * taskDelayUntil() * function is used for accurate cycle timing * @return a handle to the task, or NULL if an error occurred */ TaskHandle taskRunLoop(void (*fn)(void), const unsigned long increment); /** * Suspends the specified task. * * When suspended a task will not be scheduled, regardless of whether it might * be otherwise * available to run. * * @param taskToSuspend the task to suspend; passing NULL suspends the current * task */ void taskSuspend(TaskHandle taskToSuspend); /** * Creates a semaphore intended for synchronizing tasks. To prevent some * critical code from * simultaneously modifying a shared resource, use mutexes instead. * * Semaphores created using this function can be accessed using the * semaphoreTake() and * semaphoreGive() functions. The mutex functions must not be used on objects of * this type. * * This type of object does not need to have balanced take and give calls, so * priority * inheritance is not used. Semaphores can be signalled by an interrupt routine. * * @return a handle to the created semaphore */ Semaphore semaphoreCreate(); /** * Signals a semaphore. Tasks waiting for a signal using semaphoreTake() will be * unblocked by * this call and can continue execution. * * Slow processes can give semaphores when ready, and fast processes waiting to * take the * semaphore will continue at that point. * * @param semaphore the semaphore to signal * @return true if the semaphore was successfully given, or false if the * semaphore was not * taken since the last give */ bool semaphoreGive(Semaphore semaphore); /** * Waits on a semaphore. If the semaphore is already in the \u0026quot;taken\u0026quot; state, the * current task * will wait for the semaphore to be signaled. Other tasks can run during this * time. * * @param semaphore the semaphore to wait * @param blockTime the maximum time to wait for the semaphore to be given, * where -1 * specifies an infinite timeout * @return true if the semaphore was successfully taken, or false if the timeout * expired */ bool semaphoreTake(Semaphore semaphore, const unsigned long blockTime); /** * Deletes the specified semaphore. This function can be dangerous; deleting * semaphores being * waited on by a task may cause deadlock or a crash. * * @param semaphore the semaphore to destroy */ void semaphoreDelete(Semaphore semaphore); /** * Creates a mutex intended to allow only one task to use a resource at a time. * For signalling * and synchronization, try using semaphores. * * Mutexes created using this function can be accessed using the mutexTake() and * mutexGive() * functions. The semaphore functions must not be used on objects of this type. * * This type of object uses a priority inheritance mechanism so a task 'taking' * a mutex MUST * ALWAYS 'give' the mutex back once the mutex is no longer required. * * @return a handle to the created mutex */ Mutex mutexCreate(); /** * Relinquishes a mutex so that other tasks can use the resource it guards. The * mutex must be * held by the current task using a corresponding call to mutexTake. * * @param mutex the mutex to release * @return true if the mutex was released, or false if the mutex was not already * held */ bool mutexGive(Mutex mutex); /** * Requests a mutex so that other tasks cannot simultaneously use the resource * it guards. * The mutex must not already be held by the current task. If another task * already * holds the mutex, the function will wait for the mutex to be released. Other * tasks can run * during this time. * * @param mutex the mutex to request * @param blockTime the maximum time to wait for the mutex to be available, * where -1 * specifies an infinite timeout * @return true if the mutex was successfully taken, or false if the timeout * expired */ bool mutexTake(Mutex mutex, const unsigned long blockTime); /** * Deletes the specified mutex. This function can be dangerous; deleting * semaphores being * waited on by a task may cause deadlock or a crash. * * @param mutex the mutex to destroy */ void mutexDelete(Mutex mutex); /** * Wiring-compatible alias of taskDelay(). * * @param time the duration of the delay in milliseconds (1 000 milliseconds per * second) */ void delay(const unsigned long time); /** * Wait for approximately the given number of microseconds. * * The method used for delaying this length of time may vary depending on the * argument. * The current task will always be delayed by at least the specified period, but * possibly much * more depending on CPU load. In general, this function is less reliable than * delay(). Using * this function in a loop may hog processing time from other tasks. * * @param us the duration of the delay in microseconds (1 000 000 microseconds * per second) */ void delayMicroseconds(const unsigned long us); /** * Returns the number of microseconds since Cortex power-up. There are 10^6 * microseconds in a * second, so as a 32-bit integer, this will overflow and wrap back to zero * every two hours or * so. * * This function is Wiring-compatible. * * @return the number of microseconds since the Cortex was turned on or the last * overflow */ unsigned long micros(); /** * Returns the number of milliseconds since Cortex power-up. There are 1000 * milliseconds in a * second, so as a 32-bit integer, this will not overflow for 50 days. * * This function is Wiring-compatible. * * @return the number of milliseconds since the Cortex was turned on */ unsigned long millis(); /** * Alias of taskDelay() intended to help EasyC users. * * @param time the duration of the delay in milliseconds (1 000 milliseconds per * second) */ void wait(const unsigned long time); /** * Alias of taskDelayUntil() intended to help EasyC users. * * @param previousWakeTime a pointer to the last wakeup time * @param time the duration of the delay in milliseconds (1 000 milliseconds per * second) */ void waitUntil(unsigned long* previousWakeTime, const unsigned long time); /** * Enables IWDG watchdog timer which will reset the cortex if it locks up due to * static shock * or a misbehaving task preventing the timer to be reset. Not recovering from * static shock * will cause the robot to continue moving its motors indefinitely until turned * off manually. * * This function should only be called once in initializeIO() */ void iwdgEnable(); // End C++ extern to C #ifdef __cplusplus } #endif #endif  "
},
{
	"uri": "https://iuyte.github.io/source/include/debug.hpp/",
	"title": "include/debug.hpp",
	"tags": [],
	"description": "Code for include/debug.hpp",
	"content": "// debug.hpp: Header file for performing debugging tasks // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #pragma once #include \u0026quot;gyro.hpp\u0026quot; /** Contains debugging funtions, etc */ namespace debug { extern uint32_t fault; template \u0026lt;class T\u0026gt; static inline T unserialize(PROS_FILE* stream) { alignas(alignof(T)) char buf[sizeof(T)]; size_t nread = fread((void*)buf, sizeof(T), 1, stream); if (nread \u0026lt; sizeof(T)) { return T(); } T* out = (T*)buf; return *out; } /** Debug the Cortex if something goes wrong */ void debug(void); } // namespace debug  "
},
{
	"uri": "https://iuyte.github.io/source/include/drive.hpp/",
	"title": "include/drive.hpp",
	"tags": [],
	"description": "Code for include/drive.hpp",
	"content": "// drive.hpp: Header file for utilities relating to the drive // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #pragma once #include \u0026quot;motors.hpp\u0026quot; #include \u0026quot;sensors.hpp\u0026quot; /** Contains everything relating to the drive */ namespace drive { /** Class for a side of the drive */ struct side_t { /** Top motor on the the side */ motor_t topM; /** Middle motor on the side */ motor_t midM; /** Bottom motor on the side */ motor_t lowM; /** Sets all motors on the side to the given power */ void set(int power); /** A pointer to the sensor on the side */ sensors::quad_t* sensor; }; // struct side_t /** Multiplier for which 1 inch is used to convert into degreees rotation on * 4\u0026quot; * wheels */ extern double inch; /** The left side of the drive */ extern side_t left; /** The right side of the drive */ extern side_t right; /** Set both sides of the drive at their requested powers */ void set(int lpower, int rpower); /** Initialize the drive subsystem */ void init(void); /** Drive a specific number of inches */ void inches(long inches); /** Tank control that should be used in a while loop */ void tank(void); /** Joystick accelerometer driving! */ namespace accel { /** Current x value of the joystick accel */ extern int x; /** Current y value of the joystick accel */ extern int y; /** Previous joystick accel x value */ extern int prevX; /** Previous joystick accel y value */ extern int prevY; /** Tilt control using the josytick accelerometer. Should be used in a while * loop */ void drive(void); } // namespace accel } // namespace drive  "
},
{
	"uri": "https://iuyte.github.io/source/include/gyro.hpp/",
	"title": "include/gyro.hpp",
	"tags": [],
	"description": "Code for include/gyro.hpp",
	"content": "// gyro.hpp: Gyro utilities that provide ease of access to the robot's rotation // and manipulation of this rotation // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #pragma once #include \u0026quot;pid.hpp\u0026quot; namespace gyro { class drive { public: sensors::gyro_t* gyro; int heading; }; /** TaskHandle for the gyro heading task */ extern TaskHandle handle; } // namespace gyro  "
},
{
	"uri": "https://iuyte.github.io/source/include/lift.hpp/",
	"title": "include/lift.hpp",
	"tags": [],
	"description": "Code for include/lift.hpp",
	"content": "// lift.hpp: Header file for utilities relating to the lift // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #pragma once #include \u0026quot;drive.hpp\u0026quot; /** Contains everything relating to the drive */ namespace lift { /** Class for a side of the drive */ struct side_t { /** Top motor on the the side */ motor_t topM; /** Middle motor on the side */ motor_t midM; /** Bottom motor on the side */ motor_t lowM; /** Sets all motors on the side to the given power */ void set(int power); /** A pointer to the sensor on the side */ sensors::pot_t* sensor; }; // struct side_t /** Positions of the lift */ typedef enum { bottom = 5, mobile = 60, one = 100, two = 230, three = 450, } position; extern double inch; /** The left side of the drive */ extern side_t left; /** The right side of the drive */ extern side_t right; /** Sensor on the lift */ extern sensors::pot_t* sensor; /** Set both sides of the drive at their requested powers */ void set(int lpower, int rpower); /** Initialize the drive subsystem */ void init(void); /** p control for the lift */ void to(position pos = bottom, int int_pos = -1, int tolerance = 50); } // namespace drive  "
},
{
	"uri": "https://iuyte.github.io/source/include/main.h/",
	"title": "include/main.h",
	"tags": [],
	"description": "Code for include/main.h",
	"content": "/** @file main.h * @brief Header file for global functions * * Any experienced C or C++ programmer knows the importance of header files. For *those who * do not, a header file allows multiple files to reference functions in other *files without * necessarily having to see the code (and therefore causing a multiple *definition). To make * a function in \u0026quot;opcontrol.c\u0026quot;, \u0026quot;auto.c\u0026quot;, \u0026quot;main.c\u0026quot;, or any other C file visible *to the core * implementation files, prototype it here. *main * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * Neither the name of Purdue University ACM SIG BOTS nor the * names of its contributors may be used to endorse or promote products * derived from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0026quot;AS IS\u0026quot; *AND * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED. IN NO EVENT SHALL PURDUE UNIVERSITY ACM SIG BOTS BE LIABLE FOR *ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * * Purdue Robotics OS contains FreeRTOS (http://www.freertos.org) whose source *code may be * obtained from http://sourceforge.net/projects/freertos/files/ or on request. */ #ifndef MAIN_H_ // This prevents multiple inclusion, which isn't bad for this file but is good // practice #define MAIN_H_ #include \u0026quot;API.h\u0026quot; #include \u0026quot;debug.hpp\u0026quot; // Allow usage of this file in C++ programs #ifdef __cplusplus extern \u0026quot;C\u0026quot; { #endif //#define AUTO_DEBUG // A function prototype looks exactly like its declaration, but with a semicolon // instead of // actual code. If a function does not match a prototype, compile errors will // occur. // Prototypes for initialization, operator control and autonomous /** * Runs the user autonomous code. This function will be started in its own task * with the default * priority and stack size whenever the robot is enabled via the Field * Management System or the * VEX Competition Switch in the autonomous mode. If the robot is disabled or * communications is * lost, the autonomous task will be stopped by the kernel. Re-enabling the * robot will restart * the task, not re-start it from where it left off. * * Code running in the autonomous task cannot access information from the VEX * Joystick. However, * the autonomous function can be invoked from another task if a VEX Competition * Switch is not * available, and it can access joystick information if called in this way. * * The autonomous task may exit, unlike operatorControl() which should never * exit. If it does * so, the robot will await a switch to another mode or disable/enable cycle. */ void autonomous(); /** * Runs pre-initialization code. This function will be started in kernel mode * one time while the * VEX Cortex is starting up. As the scheduler is still paused, most API * functions will fail. * * The purpose of this function is solely to set the default pin modes * (pinMode()) and port * states (digitalWrite()) of limit switches, push buttons, and solenoids. It * can also safely * configure a UART port (usartOpen()) but cannot set up an LCD (lcdInit()). */ void initializeIO(); /** * Runs user initialization code. This function will be started in its own task * with the default * priority and stack size once when the robot is starting up. It is possible * that the VEXnet * communication link may not be fully established at this time, so reading from * the VEX * Joystick may fail. * * This function should initialize most sensors (gyro, encoders, ultrasonics), * LCDs, global * variables, and IMEs. * * This function must exit relatively promptly, or the operatorControl() and * autonomous() tasks * will not start. An autonomous mode selection menu like the pre_auton() in * other environments * can be implemented in this task if desired. */ void initialize(); /** * Runs the user operator control code. This function will be started in its own * task with the * default priority and stack size whenever the robot is enabled via the Field * Management System * or the VEX Competition Switch in the operator control mode. If the robot is * disabled or * communications is lost, the operator control task will be stopped by the * kernel. Re-enabling * the robot will restart the task, not resume it from where it left off. * * If no VEX Competition Switch or Field Management system is plugged in, the * VEX Cortex will * run the operator control task. Be warned that this will also occur if the VEX * Cortex is * tethered directly to a computer via the USB A to A cable without any VEX * Joystick attached. * * Code running in this task can take almost any action, as the VEX Joystick is * available and * the scheduler is operational. However, proper use of delay() or * taskDelayUntil() is highly * recommended to give other tasks (including system tasks such as updating * LCDs) time to run. * * This task should never exit; it should end with some kind of infinite loop, * even if empty. */ void operatorControl(); // End C++ export structure #ifdef __cplusplus } #endif #endif  "
},
{
	"uri": "https://iuyte.github.io/source/include/motors.hpp/",
	"title": "include/motors.hpp",
	"tags": [],
	"description": "Code for include/motors.hpp",
	"content": "// motors.hpp: Header file of hardware abstraction for motors and slewing // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #pragma once #include \u0026quot;API.h\u0026quot; /** Class for motor objects */ struct motor_t { /** Port the motor is pluggin in to */ unsigned char port; /** The invered status of the motor, should be 1 or -1 */ char inverted; /** The requested power value of the motor */ int power; /** A multiplier for setting the motor values */ float scale; /* The rate at which motor power should increase for every * motors::slew::slewWait milliseconds */ float slewRate; /** The last update time of the motor. Is managed by the slew task, so it * shouldn't need to be changed */ unsigned long tlast; /** Set the motor to the specified power */ void set(int power); }; // struct motor_t /** Namespace relating to the motors and setting them, initializing them, * slewing, etc */ namespace motors { /** Sets the motor to the power */ void set(motor_t motor, int power); /** Gets the current power value requested of the motor, analogous of * motor.power */ int get(motor_t motor); /** Returns an initialized motor_t object with the specified parameters, and * adds a duplicate of the motor to the motor list for slewing */ motor_t init(unsigned char port, int inverted, float slewRate, float scale); /** Namespace relating to slewing the motors to save the gears and the PTCs */ namespace slew { /** The wait time between each iteration of setting all of the motors */ static const unsigned char slewWait = 10; /** The list of motors, as added to in motors::init() */ extern motor_t list[11]; /** The TaskHandle for handling the slewing task */ extern TaskHandle handle; /** Initialization function for slewing. Call in initialize() */ void init(void); } // namespace slew } // namespace motors  "
},
{
	"uri": "https://iuyte.github.io/source/include/pid.hpp/",
	"title": "include/pid.hpp",
	"tags": [],
	"description": "Code for include/pid.hpp",
	"content": "// pid.hpp: Header file for the pid controller and all of it's assets // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #pragma once #include \u0026quot;lift.hpp\u0026quot; /** Consists of pid, and all subcomponents, etc */ namespace pid { /** Maximum value for the drive */ static const int DRIVE_MAX = 127; /** Minimum value for the drive */ static const int DRIVE_MIN = -127; /** Limit for the integral value */ static const int INTEGRAL_LIMIT = 50; /** p value */ extern float Kp; /** i value */ extern float Ki; /** d value */ extern float Kd; /** Default precision for waiting on pid to reach value */ extern unsigned int default_precision; /** Whether or not each side of the drive's pid is enabled, in the order of * left * to right */ extern bool enabled[2]; /** Enables all pid */ void enable(void); /** Disables all pid */ void disable(void); /** Task to manage pid */ void controller(void* none); /** Initialize pid. Call in initialize() */ void init(void); /** Stops the pid task */ void stop(void); /** (Re)starts the pid task */ void go(void); /** Requests values for the left and right side of the drive */ void request(long l, long r); /** Wait until pid reaches specified precision, for no longer than the * specified * blockTime. If 0 is passed to blockTime, it will wait indefinately until the * requested values are met */ void wait(unsigned long precision, unsigned long blockTime); /** TaskHandle for the pid task */ extern TaskHandle pidHandle; } // namespace pid  "
},
{
	"uri": "https://iuyte.github.io/source/include/sensors.hpp/",
	"title": "include/sensors.hpp",
	"tags": [],
	"description": "Code for include/sensors.hpp",
	"content": "// sensors.hpp: Header file for hardware abstraction of sensors // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #pragma once #include \u0026quot;API.h\u0026quot; /** The namespace containing all information, functions, objects, relating to * sensors */ namespace sensors { /** A 2-wire quadrature encoder */ struct quad_t { /** The encoder struct used by other member functions */ Encoder enc; /** The ports the encoder is connected to, in order of top, then bottom, * when * the removable cover is facing up */ unsigned char ports[2]; /** The relative zero from which the encoder's value will be returned. Can * be added to returned value to produce a true value for the encoder */ long zero; /** Whether or not the encoder is inverted */ bool inverted; /** Reset the value to zero */ void reset(void); /** Returns the relative value of the encoder. If added to the encoder's * zero, produces an absolute value of the encoder */ long value(void); /** The pid requested value of the encoder */ float request; /** The initialization function for the encoder. Call in initialize() */ void init(void); /** Constructs the encoder object. Make sure init is also called */ quad_t(unsigned char port1, unsigned char port2, bool _inverted); }; // struct quad_t /** Class for gyro objects */ class gyro_t { public: /** The gyro struct used in funtions */ Gyro gyro; /** The port the gyro is plugged into */ unsigned char port; /** The relative zero of the gyro, such that you can add it to the returned * value to obtain an absolute value */ long zero; /** Resets the value to 0 */ void reset(void); /** Returns the current value of the gyro, relative to the zero */ long value(void); /** The pid requested value of the gyro */ float request; /** Initialization funtion for the gyro, call in initialize() */ void init(void); /** Class constructor, but it must not be forgotten to call init() */ gyro_t(unsigned char _port, unsigned int _calibration); private: /** The calibration, a temporary placement between construction and * initialization */ int calibration; }; // struct gyro_t /** Class for potentiometers */ struct pot_t { /** The port that the pot is plugged in to */ unsigned char port; /** The relative zero, that can be added to the returned value() to find the * absolute value */ long zero; /** Whether or not the potentioeter's value should be inverted */ bool inverted; /** Resets the value to 0 */ void reset(void); /** Returns the relative value of the potentiometer */ long value(void); /** The pid requested value of the pot */ float request; /** The initialization funtion for the potentiometer, which must be called * in * initialize() */ void init(void); /** The class constructor for a potentiometer, also be sure to init() */ pot_t(unsigned char _port, bool _inverted); }; // pot_t /** Class for ultrasonic sensors */ struct sonic_t { /** The Ultrasonic struct that is referenced in member funtions */ Ultrasonic sonic; /** The two ports the sensor is plugged in to, in order of the echo (aka * orange) cable, then the ping (aka yellow) cable */ unsigned char ports[2]; /** The value of the ultrasonic sensor */ long value(void); /** Initializes the sensor. Call in initialize() */ void init(void); /** Class constructor, but init() must also be called */ sonic_t(unsigned char port1, unsigned char port2); }; // sonic_t /** Class for buttons */ struct button_t { /** the port that the button is plugged in to */ unsigned char port; /** Whether or not the button's value should be inverted */ bool inverted; /** Returns true if the button is pressed */ bool value(void); /** Initializes the button. Call in initialize() */ void init(void); /** Class constructor, but init() must also be called */ button_t(unsigned char _port, bool _inverted); }; // button_t /** Initializes the sensor subsystem, calls all the funtions that need to be * called in initialize(). Call in initialize() */ void init(void); /** Resets the important sensors */ void reset(void); /** left quad encoder on the drive */ extern quad_t left; /** right quad encoder on the drive */ extern quad_t right; /** potentiometer on the lift */ extern pot_t lift; /** gyro on the drive */ extern gyro_t gyro; } // namespace sensors  "
},
{
	"uri": "https://iuyte.github.io/source/src/auto.cpp/",
	"title": "src/auto.cpp",
	"tags": [],
	"description": "Code for src/auto.cpp",
	"content": "// auto.cpp: Ultimately where the auton mode procedure is determined and run // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/main.h\u0026quot; void autonomous() { sensors::reset(); drive::inches(12); }  "
},
{
	"uri": "https://iuyte.github.io/source/src/debug.cpp/",
	"title": "src/debug.cpp",
	"tags": [],
	"description": "Code for src/debug.cpp",
	"content": "// debug.cpp: Source file for advanced debugging // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/debug.hpp\u0026quot; namespace debug { uint32_t fault = 0; void debug(void) { PROS_FILE* fd = fopen(\u0026quot;FAULT_PC\u0026quot;, \u0026quot;r\u0026quot;); if (fd) { fault = unserialize\u0026lt;uint32_t\u0026gt;(fd); if (!fault) { fault = 0xFFFFFFFF; } fclose(fd); } printf(\u0026quot;%lu\u0026quot;, fault); } } // namespace debug  "
},
{
	"uri": "https://iuyte.github.io/source/src/drive.cpp/",
	"title": "src/drive.cpp",
	"tags": [],
	"description": "Code for src/drive.cpp",
	"content": "// drive.cpp: Source file for utilities relating to the drive // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/main.h\u0026quot; namespace drive { side_t left; side_t right; double inch = 28.64788975654116043839907740705258516620273623328216077458012735; void side_t::set(int power) { side_t::topM.set(power); side_t::midM.set(power); side_t::lowM.set(power); } void init(void) { left.topM = motors::init(2, 1, .5, .8); left.midM = motors::init(3, -1, .5, .8); left.lowM = motors::init(4, 1, .5, .8); right.topM = motors::init(7, -1, .5, .8); right.midM = motors::init(8, 1, .5, .8); right.lowM = motors::init(9, -1, .5, .8); left.sensor = \u0026amp;sensors::left; right.sensor = \u0026amp;sensors::right; } void set(int lpower, int rpower) { left.set(lpower); right.set(rpower); } void tank(void) { int deadband = 20; int lj = joystickGetAnalog(1, 3); int rj = joystickGetAnalog(1, 2); if (abs(lj) \u0026lt; deadband \u0026amp;\u0026amp; abs(rj) \u0026lt; deadband) { pid::enable(); return; } lj = (abs(lj) \u0026lt; deadband) ? 0 : lj; rj = (abs(rj) \u0026lt; deadband) ? 0 : rj; pid::enabled[0] = (lj == 0); pid::enabled[1] = (rj == 0); if (lj != 0) left.set(lj); if (rj != 0) right.set(rj); pid::request((lj == 0) ? left.sensor-\u0026gt;request : left.sensor-\u0026gt;value(), (rj == 0) ? right.sensor-\u0026gt;request : right.sensor-\u0026gt;value()); } namespace accel { int deadband = 20; int x = 0; int y = 0; int prevX = 0; int prevY = 0; void drive(void) { prevX = x; prevY = y; x = 0 - joystickGetAnalog(1, ACCEL_X); y = 0 - joystickGetAnalog(1, ACCEL_Y); int threshold = 20; double multiplier = 1.1; if (abs(x) \u0026lt; threshold) x = 0; if (abs(y) \u0026lt; threshold) y = 0; x *= multiplier; y *= (multiplier * 1.25); int lj = x - y; int rj = x + y; lj = (abs(lj) \u0026lt; deadband) ? 0 : lj; rj = (abs(rj) \u0026lt; deadband) ? 0 : rj; pid::enabled[0] = (lj == 0); pid::enabled[1] = (rj == 0); if (lj != 0) left.set(lj); if (rj != 0) right.set(rj); pid::request((lj == 0) ? left.sensor-\u0026gt;request : left.sensor-\u0026gt;value(), (rj == 0) ? right.sensor-\u0026gt;request : right.sensor-\u0026gt;value()); } } // namespace accel void inches(long inches) { pid::enable(); left.sensor-\u0026gt;request += inches * inch; right.sensor-\u0026gt;request += inches * inch; pid::wait(pid::default_precision, inches * inches * 8); pid::disable(); } } // namespace drive  "
},
{
	"uri": "https://iuyte.github.io/source/src/gyro.cpp/",
	"title": "src/gyro.cpp",
	"tags": [],
	"description": "Code for src/gyro.cpp",
	"content": "// gyro.cpp: Gyro utilities that provide ease of access to the robot's rotation // and manipulation of this rotation // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/main.h\u0026quot; namespace gyro { extern TaskHandle handle; } // namespace gyro  "
},
{
	"uri": "https://iuyte.github.io/source/src/init.cpp/",
	"title": "src/init.cpp",
	"tags": [],
	"description": "Code for src/init.cpp",
	"content": "// init.cpp: Handles the initialization of everything needed, ie. sensors, pid. // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/main.h\u0026quot; extern \u0026quot;C\u0026quot; { void __libc_init_array(); } void initializeIO() { __libc_init_array(); } void initialize() { motors::slew::init(); drive::init(); sensors::init(); pid::init(); }  "
},
{
	"uri": "https://iuyte.github.io/source/src/lift.cpp/",
	"title": "src/lift.cpp",
	"tags": [],
	"description": "Code for src/lift.cpp",
	"content": "// lift.cpp: Source file for utilities relating to the lift // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/lift.hpp\u0026quot; namespace lift { side_t left; side_t right; sensors::pot_t* sensor = \u0026amp;sensors::lift; void side_t::set(int power) { side_t::topM.set(power); side_t::midM.set(power); side_t::lowM.set(power); } void init(void) { left.topM = motors::init(2, 1, .5, .8); left.midM = motors::init(3, -1, .5, .8); left.lowM = motors::init(4, 1, .5, .8); right.topM = motors::init(7, -1, .5, .8); right.midM = motors::init(8, 1, .5, .8); right.lowM = motors::init(9, -1, .5, .8); left.sensor = \u0026amp;sensors::lift; right.sensor = \u0026amp;sensors::lift; } void set(int power) { left.set(power); right.set(power); } void to(position pos, int int_pos, int tolerance) { if (int_pos == -1) int_pos = pos; do { set((int_pos \u0026gt; sensor-\u0026gt;value() + tolerance || int_pos \u0026lt; sensor-\u0026gt;value() - tolerance) ? (sensor-\u0026gt;value() - int_pos) * 2 : (sensor-\u0026gt;value() - int_pos)); delay(15); } while (int_pos \u0026gt; sensor-\u0026gt;value() + tolerance || int_pos \u0026lt; sensor-\u0026gt;value() - tolerance); set(15); return; } } // namespace drive  "
},
{
	"uri": "https://iuyte.github.io/source/src/motors.cpp/",
	"title": "src/motors.cpp",
	"tags": [],
	"description": "Code for src/motors.cpp",
	"content": "// motors.cpp: Source file of hardware abstraction for motors and slewing // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/motors.hpp\u0026quot; void motor_t::set(int _power) { power = motors::slew::list[port].power = _power * inverted * scale; } namespace motors { void set(motor_t motor, int power) { motor.set(power); } int get(motor_t motor) { return motor.power; } motor_t init(unsigned char port, int inverted, float slewRate, float scale) { motor_t motor; motor.port = port; motor.inverted = inverted; motor.slewRate = slewRate; motor.scale = scale; slew::list[motor.port] = motor; return motor; } namespace slew { motor_t list[11]; TaskHandle handle; void _slew(void* none) { unsigned long int current; while (true) { current = millis(); for (size_t i = 1; i \u0026lt;= 10; i++) { motorSet(i, (int)(((list[i].power - motorGet(i)) * list[i].slewRate) + ((list[i].power \u0026gt;= motorGet(i)) ? (current - list[i].tlast - slewWait) : (-1 * (current - list[i].tlast - slewWait))) + motorGet(i))); list[i].tlast = current; } delay(slewWait); } free(none); } void init(void) { motor_t default_motor; default_motor.inverted = 1; default_motor.slewRate = 1; default_motor.scale = 0; for (size_t i = 1; i \u0026lt;= 11; i++) { list[i] = default_motor; default_motor.port = i; } handle = taskCreate(\u0026amp;_slew, TASK_DEFAULT_STACK_SIZE, NULL, TASK_PRIORITY_DEFAULT + 1); } } // namespace slew } // namespace motors  "
},
{
	"uri": "https://iuyte.github.io/source/src/opcontrol.cpp/",
	"title": "src/opcontrol.cpp",
	"tags": [],
	"description": "Code for src/opcontrol.cpp",
	"content": "// opcontrol.cpp: Handles the interaction and procedure of opcontrol mode // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/main.h\u0026quot; bool tank = true; bool wpressed = false; void operatorControl() { sensors::reset(); while (true) { if (tank) { drive::tank(); } else { drive::accel::drive(); } if (!wpressed \u0026amp;\u0026amp; joystickGetDigital(1, 7, JOY_DOWN)) { tank = !tank; } else { wpressed = joystickGetDigital(1, 7, JOY_DOWN); } debug::debug(); delay(50); } }  "
},
{
	"uri": "https://iuyte.github.io/source/src/pid.cpp/",
	"title": "src/pid.cpp",
	"tags": [],
	"description": "Code for src/pid.cpp",
	"content": "// pid.cpp: Source file for pid and all of it's assets // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/pid.hpp\u0026quot; int sgn(float __x); namespace pid { float Kp = 0.8; float Ki = 0.04; float Kd = 0.35; unsigned int deadband = 10; bool enabled[2] = {true, true}; unsigned int default_precision = 30; TaskHandle pidHandle; void controller(void* none) { float current[2]; float error[2]; float lastError[2] = {0, 0}; float integral[2] = {0, 0}; float derivative[2]; float power[2]; sensors::left.reset(); sensors::right.reset(); sensors::quad_t* sides[2] = {\u0026amp;sensors::left, \u0026amp;sensors::right}; while (true) { printf(\u0026quot;| %ld | %ld |\\n\u0026quot;, sensors::left.value(), sensors::right.value()); for (size_t i = 0; i \u0026lt; 2; i++) { if (enabled[i]) { current[i] = sides[i]-\u0026gt;value(); error[i] = sides[i]-\u0026gt;request - current[i]; if ((unsigned int)abs((int)error[i]) \u0026lt;= deadband) { continue; } integral[i] = (Ki != 0 \u0026amp;\u0026amp; abs((int)error[i]) \u0026lt; INTEGRAL_LIMIT) ? (integral[i] + error[i]) : 0; derivative[i] = error[i] - lastError[i]; lastError[i] = error[i]; power[i] = (Kp * error[i]) + (Ki * integral[i]) + (Kd * derivative[i]); power[i] = (power[i] \u0026lt;= DRIVE_MIN) ? DRIVE_MIN : ((power[i] \u0026gt;= DRIVE_MAX) ? DRIVE_MAX : power[i]); power[i] *= 8.1f / powerLevelMain(); (i == 0) ? drive::left.set(power[i]) : drive::right.set(power[i]); } } delay(25); } free(none); } void enable(void) { enabled[0] = true; enabled[1] = true; } void disable(void) { enabled[0] = false; enabled[1] = false; } void init(void) { pidHandle = taskCreate(controller, TASK_DEFAULT_STACK_SIZE, NULL, TASK_PRIORITY_DEFAULT); } void stop(void) { taskSuspend(pidHandle); } void go(void) { taskResume(pidHandle); } void request(long l, long r) { sensors::left.request = l; sensors::right.request = r; } void wait(unsigned long precision, unsigned long blockTime) { if (blockTime \u0026gt; 0) { auto start = millis(); while ((sensors::left.value() \u0026gt; sensors::left.request + precision || sensors::left.value() \u0026lt; sensors::left.request - precision || sensors::right.value() \u0026gt; sensors::right.request + precision || sensors::right.value() \u0026lt; sensors::right.request - precision) \u0026amp;\u0026amp; millis() - start \u0026lt;= blockTime) { delay(50); } } else { while ((sensors::left.value() \u0026gt; sensors::left.request + precision || sensors::left.value() \u0026lt; sensors::left.request - precision || sensors::right.value() \u0026gt; sensors::right.request + precision || sensors::right.value() \u0026lt; sensors::right.request - precision)) { delay(50); } } } } int sgn(float __x) { if (__x \u0026gt; 0) return 1; if (__x \u0026lt; 0) return -1; return 0; } // namespace pid  "
},
{
	"uri": "https://iuyte.github.io/source/src/sensors.cpp/",
	"title": "src/sensors.cpp",
	"tags": [],
	"description": "Code for src/sensors.cpp",
	"content": "// sensors.cpp: Source file for hardware abstraction of sensors // Copyright (C) 2017 Ethan Wells // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;. #include \u0026quot;../include/main.h\u0026quot; namespace sensors { quad_t left(1, 2, false); quad_t right(3, 4, false); pot_t lift(1, false); gyro_t gyro(2, 197); quad_t::quad_t(unsigned char port1, unsigned char port2, bool _inverted) { ports[0] = port1; ports[1] = port2; inverted = _inverted; zero = 0; request = 0; } void quad_t::init(void) { enc = encoderInit(quad_t::ports[0], quad_t::ports[1], quad_t::inverted); } long quad_t::value(void) { return (encoderGet(enc) - zero); } void quad_t::reset(void) { zero = encoderGet(enc); request = 0; } gyro_t::gyro_t(unsigned char _port, unsigned int _calibration) { port = _port; calibration = _calibration; zero = 0; request = 0; } void gyro_t::init(void) { gyro_t::gyro = gyroInit(port, calibration); } long gyro_t::value(void) { return (gyroGet(gyro_t::gyro) - zero); } void gyro_t::reset(void) { zero = gyroGet(gyro_t::gyro); request = 0; } pot_t::pot_t(unsigned char _port, bool _inverted) { port = _port; inverted = _inverted; zero = 0; request = 0; } void pot_t::init(void) { analogCalibrate(port); } long pot_t::value(void) { return ((analogReadCalibrated(port) - zero) * ((inverted) ? -1 : 1)); } void pot_t::reset(void) { zero = analogReadCalibrated(port); request = 0; } sonic_t::sonic_t(unsigned char port1, unsigned char port2) { ports[0] = port1; ports[1] = port2; } void sonic_t::init(void) { sonic = ultrasonicInit(sonic_t::ports[0], sonic_t::ports[1]); } long sonic_t::value(void) { return ultrasonicGet(sonic); } button_t::button_t(unsigned char _port, bool _inverted) { port = _port; inverted = _inverted; } void button_t::init(void) { pinMode(port, INPUT); } bool button_t::value(void) { return (digitalRead(port)) ? ((inverted) ? false : true) : ((inverted) ? true : false); } void init(void) { left.init(); right.init(); lift.init(); gyro.init(); } void reset(void) { left.reset(); right.reset(); } } // namespace sensors  "
}]